--- FILE: ./mobile-app/lib/features/components/transaction_list_item.dart ---
import 'package:flutter/material.dart';
import 'package:quantus_sdk/quantus_sdk.dart';

class TransactionListItem extends StatelessWidget {
  final Transaction transaction;
  final bool isReceived;

  const TransactionListItem({
    super.key,
    required this.transaction,
    required this.isReceived,
  });

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: isReceived ? Colors.green.useOpacity(0.2) : Colors.red.useOpacity(0.2),
          shape: BoxShape.circle,
        ),
        child: Icon(
          isReceived ? Icons.arrow_downward : Icons.arrow_upward,
          color: isReceived ? Colors.green : Colors.red,
        ),
      ),
      title: Text(
        isReceived ? 'Received' : 'Sent',
        style: const TextStyle(fontWeight: FontWeight.bold),
      ),
      subtitle: Text(
        transaction.otherParty,
        style: const TextStyle(fontSize: 12),
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      trailing: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text(
            '${isReceived ? '+' : '-'}${NumberFormattingService().formatBalance(transaction.amount)} REZ',
            style: TextStyle(
              fontWeight: FontWeight.bold,
              color: isReceived ? Colors.green : Colors.red,
            ),
          ),
          Text(
            transaction.status.name,
            style: const TextStyle(fontSize: 12, color: Colors.grey),
          ),
        ],
      ),
    );
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/send_progress_overlay.dart ---
import 'dart:ui';

import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:quantus_sdk/quantus_sdk.dart';
import 'package:resonance_network_wallet/features/main/screens/wallet_main.dart';

enum SendOverlayState { confirm, progress, complete }

class SendConfirmationOverlay extends StatefulWidget {
  final BigInt amount;
  final String recipientName;
  final String recipientAddress;
  final VoidCallback onClose;
  final BigInt fee;

  const SendConfirmationOverlay({
    required this.amount,
    required this.recipientName,
    required this.recipientAddress,
    required this.onClose,
    required this.fee,
    super.key,
  });

  @override
  SendConfirmationOverlayState createState() => SendConfirmationOverlayState();
}

class SendConfirmationOverlayState extends State<SendConfirmationOverlay> {
  SendOverlayState _currentState = SendOverlayState.confirm;
  String? _errorMessage;
  bool _isSending = false;
  final NumberFormattingService _formattingService = NumberFormattingService();
  final SettingsService _settingsService = SettingsService();

  Future<void> _confirmSend() async {
    if (_isSending) return;

    setState(() {
      _isSending = true;
      _currentState = SendOverlayState.progress;
      _errorMessage = null;
    });

    try {
      final senderSeed = await _settingsService.getMnemonic();

      if (senderSeed == null || senderSeed.isEmpty) {
        throw Exception('Sender mnemonic not found. Please re-import your wallet.');
      }

      debugPrint('Attempting balance transfer...');
      debugPrint('  Sender Seed: ${senderSeed.substring(0, 4)}...');
      debugPrint('  Recipient: ${widget.recipientAddress}');
      debugPrint('  Amount (BigInt): ${widget.amount}');

      await SubstrateService().balanceTransfer(senderSeed, widget.recipientAddress, widget.amount);

      debugPrint('Balance transfer successful.');

      if (mounted) {
        setState(() {
          _currentState = SendOverlayState.complete;
          _isSending = false;
        });
      }
    } catch (e) {
      debugPrint('Balance transfer failed: $e');
      if (mounted) {
        setState(() {
          _currentState = SendOverlayState.confirm;
          _errorMessage = 'Transfer failed: ${e.toString()}';
          _isSending = false;
        });
      }
    }
  }

  Widget _buildConfirmState(BuildContext context) {
    final formattedAmount = _formattingService.formatBalance(widget.amount);
    final formattedFee = _formattingService.formatBalance(widget.fee);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(7),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              GestureDetector(
                onTap: widget.onClose,
                child: Container(
                  width: 24,
                  height: 24,
                  decoration: const ShapeDecoration(
                    color: Colors.white,
                    shape: OvalBorder(),
                  ),
                  child: const Icon(Icons.close, color: Colors.black, size: 18),
                ),
              ),
            ],
          ),
        ),
        const SizedBox(height: 28),
        Row(
          children: [
            Container(
              width: 49,
              height: 40,
              decoration: BoxDecoration(
                color: Colors.white.useOpacity(0.1),
                borderRadius: BorderRadius.circular(5),
              ),
              child: SvgPicture.asset(
                'assets/send_icon_1.svg',
                width: 24,
                height: 24,
              ),
            ),
            const SizedBox(width: 7),
            const Text(
              'SEND',
              style: TextStyle(
                color: Colors.white,
                fontSize: 28,
                fontFamily: 'Fira Code',
                fontWeight: FontWeight.w300,
              ),
            ),
          ],
        ),
        const SizedBox(height: 28),
        Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  width: 25,
                  height: 25,
                  decoration: const ShapeDecoration(
                    color: Colors.white,
                    shape: OvalBorder(),
                  ),
                  child: Center(
                    child: SvgPicture.asset(
                      'assets/res_icon.svg',
                    ),
                  ),
                ),
                const SizedBox(width: 13),
                Text.rich(
                  TextSpan(
                    children: [
                      TextSpan(
                        text: formattedAmount,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 24,
                          fontFamily: 'Fira Code',
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                      const TextSpan(
                        text: ' ${AppConstants.tokenSymbol}',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 12,
                          fontFamily: 'Fira Code',
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 13),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'To:',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 12,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w300,
                  ),
                ),
                const SizedBox(height: 2),
                SizedBox(
                  width: 252,
                  child: Text(
                    widget.recipientName,
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontFamily: 'Fira Code',
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
                Text(
                  widget.recipientAddress,
                  style: TextStyle(
                    color: Colors.white.useOpacity(0.6),
                    fontSize: 10,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w300,
                  ),
                ),
              ],
            ),
          ],
        ),
        if (_errorMessage != null)
          Padding(
            padding: const EdgeInsets.only(top: 16.0, bottom: 8.0),
            child: Center(
              child: Text(
                _errorMessage!,
                style: const TextStyle(color: Colors.red, fontSize: 12, fontFamily: 'Fira Code'),
                textAlign: TextAlign.center,
              ),
            ),
          ),
        const SizedBox(height: 28),
        SizedBox(
          width: double.infinity,
          child: Column(
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    'Network fee',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontFamily: 'Fira Code',
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  Text(
                    '$formattedFee ${AppConstants.tokenSymbol}',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontFamily: 'Fira Code',
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 23),
              GestureDetector(
                onTap: _isSending ? null : _confirmSend,
                child: Opacity(
                  opacity: _isSending ? 0.5 : 1.0,
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(16),
                    decoration: ShapeDecoration(
                      color: Colors.white,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(5),
                      ),
                    ),
                    child: const Text(
                      'Confirm',
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: Color(0xFF0E0E0E),
                        fontSize: 18,
                        fontFamily: 'Fira Code',
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 50),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildProgressState(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      mainAxisAlignment: MainAxisAlignment.start,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(7),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              GestureDetector(
                onTap: widget.onClose,
                child: Container(
                  width: 24,
                  height: 24,
                  decoration: const ShapeDecoration(
                    color: Colors.white,
                    shape: OvalBorder(),
                  ),
                  child: const Icon(Icons.close, color: Colors.black, size: 18),
                ),
              ),
            ],
          ),
        ),
        const SizedBox(height: 91),
        SizedBox(
          width: 126,
          height: 178,
          child: Stack(
            alignment: Alignment.center,
            children: [
              Positioned(
                top: 0,
                child: SizedBox(
                  width: 85,
                  height: 85,
                  child: SvgPicture.asset(
                    'assets/res_icon.svg',
                  ),
                ),
              ),
              const Positioned(
                bottom: 0,
                child: Text(
                  'SENDING',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 30,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w300,
                  ),
                ),
              ),
            ],
          ),
        ),
        const SizedBox(height: 91),
      ],
    );
  }

  Widget _buildCompleteState(BuildContext context) {
    final formattedAmount = _formattingService.formatBalance(widget.amount);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(7),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              GestureDetector(
                onTap: widget.onClose,
                child: Container(
                  width: 24,
                  height: 24,
                  decoration: const ShapeDecoration(
                    color: Colors.white,
                    shape: OvalBorder(),
                  ),
                  child: const Icon(Icons.close, color: Colors.black, size: 18),
                ),
              ),
            ],
          ),
        ),
        const SizedBox(height: 91 - 24),
        Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            SizedBox(
              width: 126,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  SizedBox(
                    width: 85,
                    height: 85,
                    child: SvgPicture.asset('assets/res_icon.svg'),
                  ),
                  const SizedBox(height: 17),
                  const SizedBox(
                    width: 126,
                    child: Text(
                      'SENT',
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 30,
                        fontFamily: 'Fira Code',
                        fontWeight: FontWeight.w300,
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 46),
            SizedBox(
              width: 305,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(
                    width: 305,
                    child: Text.rich(
                      TextSpan(
                        children: [
                          TextSpan(
                            text: '$formattedAmount ${AppConstants.tokenSymbol} ',
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 12,
                              fontFamily: 'Fira Code',
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          TextSpan(
                            text: 'was successfully sent to ',
                            style: TextStyle(
                              color: Colors.white.useOpacity(0.5),
                              fontSize: 12,
                              fontFamily: 'Fira Code',
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          TextSpan(
                            text: widget.recipientName,
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 12,
                              fontFamily: 'Fira Code',
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ],
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ),
                  const SizedBox(height: 18),
                  SizedBox(
                    width: 305,
                    child: GestureDetector(
                      onTap: () {
                        // TODO: Implement view transaction logic
                      },
                      child: const Text(
                        'View Transaction',
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: Color(0xFF16CECE),
                          fontSize: 12,
                          fontFamily: 'Fira Code',
                          fontWeight: FontWeight.w500,
                          decoration: TextDecoration.underline,
                          decorationColor: Color(0xFF16CECE),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        const SizedBox(height: 46),
        GestureDetector(
          onTap: () {
            Navigator.pushAndRemoveUntil(
              context,
              MaterialPageRoute(builder: (context) => const WalletMain()),
              (route) => false,
            );
          },
          child: Container(
            width: double.infinity,
            padding: const EdgeInsets.all(16),
            decoration: ShapeDecoration(
              color: Colors.white,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(5),
              ),
            ),
            child: const Text(
              'Done',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Color(0xFF0E0E0E),
                fontSize: 18,
                fontFamily: 'Fira Code',
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        ),
        const SizedBox(height: 50),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    Widget content;
    switch (_currentState) {
      case SendOverlayState.confirm:
        content = _buildConfirmState(context);
        break;
      case SendOverlayState.progress:
        content = _buildProgressState(context);
        break;
      case SendOverlayState.complete:
        content = _buildCompleteState(context);
        break;
    }

    return SafeArea(
      child: Stack(
        alignment: Alignment.center,
        children: [
          Positioned.fill(
            child: BackdropFilter(
              filter: ImageFilter.blur(sigmaX: 5, sigmaY: 5),
              child: Container(
                color: Colors.black.useOpacity(0.3),
              ),
            ),
          ),
          Container(
            width: MediaQuery.of(context).size.width,
            padding: const EdgeInsets.symmetric(horizontal: 35, vertical: 16),
            decoration: ShapeDecoration(
              color: Colors.black,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
            ),
            child: content,
          ),
        ],
      ),
    );
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/account_profile.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:quantus_sdk/quantus_sdk.dart';
import 'package:flutter_svg/flutter_svg.dart';

class AccountInfo {
  final String name;
  final String address;
  final String balance;

  AccountInfo({required this.name, required this.address, required this.balance});
}

class AccountProfilePage extends StatefulWidget {
  final String currentAccountId;

  const AccountProfilePage({
    super.key,
    required this.currentAccountId,
  });

  @override
  State<AccountProfilePage> createState() => _AccountProfilePageState();
}

class _AccountProfilePageState extends State<AccountProfilePage> {
  AccountInfo? _account;
  bool _isLoading = true;
  final NumberFormattingService _formattingService = NumberFormattingService();
  final HumanReadableChecksumService _checksumService = HumanReadableChecksumService();
  final SettingsService _settingsService = SettingsService();

  @override
  void initState() {
    super.initState();
    _checksumService.initialize();
    _loadAccountData();
  }

  Future<void> _loadAccountData() async {
    setState(() {
      _isLoading = true;
    });
    try {
      final accountId = await _settingsService.getAccountId();

      if (accountId == null) {
        throw Exception('No account found');
      }

      final balance = await SubstrateService().queryBalance(accountId);
      final formattedBalance = _formattingService.formatBalance(balance);

      setState(() {
        _account = AccountInfo(
          name: '',
          address: accountId,
          balance: formattedBalance,
        );
        _isLoading = false;
      });
    } catch (e) {
      debugPrint('Error loading account data: $e');
      setState(() {
        _isLoading = false;
      });
    }
  }

  void _createNewWallet() {
    debugPrint('Create New Wallet tapped');
    showTopSnackBar(
      context,
      title: 'Info',
      message: 'Create New Wallet action not implemented yet.',
    );
  }

  void _showLogoutConfirmationSheet(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (BuildContext bc) {
        return Padding(
          padding: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 35, vertical: 16),
            decoration: const ShapeDecoration(
              color: Colors.black,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
              ),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Align(
                  alignment: Alignment.topRight,
                  child: IconButton(
                    icon: const Icon(Icons.close, color: Colors.white54),
                    onPressed: () => Navigator.pop(context),
                  ),
                ),
                const SizedBox(height: 10),
                const Text(
                  'Confirm Logout',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 28,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w300,
                  ),
                ),
                const SizedBox(height: 13),
                const SizedBox(
                  width: double.infinity,
                  child: Text(
                    'Are you sure you want to Logout? This will delete all local wallet data. Make sure you have backed up your recovery phrase.',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 14,
                      fontFamily: 'Fira Code',
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
                const SizedBox(height: 28),
                GestureDetector(
                  onTap: () async {
                    Navigator.pop(context);
                    try {
                      await SubstrateService().logout();
                      if (mounted) {
                        Navigator.of(context).pushNamedAndRemoveUntil('/', (route) => false);
                      }
                    } catch (e) {
                      debugPrint('Error during logout: $e');
                      if (mounted) {
                        showTopSnackBar(
                          context,
                          title: 'Error',
                          message: 'Logout failed: ${e.toString()}',
                          icon: buildErrorIcon(),
                        );
                      }
                    }
                  },
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(16),
                    decoration: ShapeDecoration(
                      color: const Color(0xFFFF2D53),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
                    ),
                    child: const Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        Text(
                          'Reset & Clear Data',
                          style: TextStyle(
                            color: Color(0xFF0E0E0E),
                            fontSize: 18,
                            fontFamily: 'Fira Code',
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                const SizedBox(height: 28),
                GestureDetector(
                  onTap: () => Navigator.pop(context),
                  child: const SizedBox(
                    width: double.infinity,
                    child: Text(
                      'Cancel',
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: Color(0xFFFF1D25),
                        fontSize: 14,
                        fontFamily: 'Fira Code',
                        fontWeight: FontWeight.w500,
                        decoration: TextDecoration.underline,
                        decorationColor: Color(0xFFFF1D25),
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 20),
              ],
            ),
          ),
        );
      },
    );
  }

  void _logoutAndClearData() async {
    debugPrint('Log Out tapped');
    _showLogoutConfirmationSheet(context);
  }

  void _copyAddress(String address) {
    Clipboard.setData(ClipboardData(text: address));
    showTopSnackBar(
      context,
      title: 'Copied!',
      message: 'Address copied to clipboard',
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF0E0E0E),
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        title: const Text(
          'Your Accounts',
          style: TextStyle(
            color: Colors.white,
            fontSize: 14,
            fontFamily: 'Fira Code',
            fontWeight: FontWeight.w400,
          ),
        ),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => Navigator.of(context).pop(),
        ),
      ),
      body: Container(
        decoration: const BoxDecoration(
          image: DecorationImage(
            image: AssetImage('assets/light_leak_effect_background.jpg'),
            fit: BoxFit.cover,
            opacity: 0.54,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Column(
              children: [
                if (_isLoading)
                  const Expanded(
                    child: Center(
                      child: CircularProgressIndicator(color: Colors.white),
                    ),
                  )
                else if (_account == null)
                  const Expanded(
                    child: Center(
                      child: Text(
                        'No account found',
                        style: TextStyle(color: Colors.white),
                      ),
                    ),
                  )
                else
                  Expanded(
                    child: ListView(
                      children: [
                        _buildAccountItem(_account!, true),
                      ],
                    ),
                  ),
                const SizedBox(height: 24),
                _buildActionButton(
                  text: 'Create New Wallet',
                  onPressed: _createNewWallet,
                  isOutlined: true,
                ),
                const SizedBox(height: 16),
                _buildActionButton(
                  text: 'Log Out & Clear Data',
                  onPressed: _logoutAndClearData,
                  isOutlined: false,
                  backgroundColor: const Color(0xFFE6E6E6),
                  textColor: const Color(0xFF0E0E0E),
                ),
                const SizedBox(height: 24),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildAccountItem(AccountInfo account, bool isActive) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
      decoration: ShapeDecoration(
        color: Colors.black.useOpacity(166 / 255.0),
        shape: RoundedRectangleBorder(
          side: isActive ? const BorderSide(width: 1, color: Colors.white) : BorderSide.none,
          borderRadius: BorderRadius.circular(5),
        ),
      ),
      child: Row(
        children: [
          SvgPicture.asset(
            'assets/account_list_icon.svg',
            width: 21,
            height: 32,
          ),
          const SizedBox(width: 15),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                FutureBuilder<String?>(
                  future: _checksumService.getHumanReadableName(account.address),
                  builder: (context, snapshot) {
                    if (snapshot.connectionState == ConnectionState.waiting) {
                      return const SizedBox(
                          height: 14,
                          child: Row(children: [
                            SizedBox(
                                width: 14,
                                height: 14,
                                child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white54)),
                          ]));
                    } else if (snapshot.hasError) {
                      debugPrint('Error fetching identity name for ${account.address}: ${snapshot.error}');
                      return Text(
                        account.name,
                        style: const TextStyle(
                          color: Colors.white70,
                          fontSize: 14,
                          fontFamily: 'Fira Code',
                          fontWeight: FontWeight.w400,
                        ),
                        overflow: TextOverflow.ellipsis,
                      );
                    } else if (snapshot.hasData && snapshot.data != null && snapshot.data!.isNotEmpty) {
                      return Text(
                        snapshot.data!,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 14,
                          fontFamily: 'Fira Code',
                          fontWeight: FontWeight.w400,
                        ),
                        overflow: TextOverflow.ellipsis,
                      );
                    } else {
                      return Text(
                        account.name,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 14,
                          fontFamily: 'Fira Code',
                          fontWeight: FontWeight.w400,
                        ),
                        overflow: TextOverflow.ellipsis,
                      );
                    }
                  },
                ),
                const SizedBox(height: 4),
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        account.address,
                        style: TextStyle(
                          color: Colors.white.useOpacity(153 / 255.0),
                          fontSize: 10,
                          fontFamily: 'Fira Code',
                          fontWeight: FontWeight.w300,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    const SizedBox(width: 5),
                    InkWell(
                      onTap: () => _copyAddress(account.address),
                      child: const Icon(
                        Icons.content_copy,
                        color: Colors.white70,
                        size: 14,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 4),
                Text.rich(
                  TextSpan(
                    children: [
                      TextSpan(
                        text: account.balance,
                        style: const TextStyle(
                          color: Color(0xFFE6E6E6),
                          fontSize: 12,
                          fontFamily: 'Fira Code',
                          fontWeight: FontWeight.w400,
                        ),
                      ),
                      const TextSpan(
                        text: ' ${AppConstants.tokenSymbol}',
                        style: TextStyle(
                          color: Color(0xFFE6E6E6),
                          fontSize: 10,
                          fontFamily: 'Fira Code',
                          fontWeight: FontWeight.w400,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildActionButton({
    required String text,
    required VoidCallback onPressed,
    required bool isOutlined,
    Color? backgroundColor,
    Color? textColor,
  }) {
    final ButtonStyle style = isOutlined
        ? OutlinedButton.styleFrom(
            foregroundColor: const Color(0xFFE6E6E6),
            side: const BorderSide(width: 1, color: Color(0xFFE6E6E6)),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
            minimumSize: const Size(double.infinity, 50),
            textStyle: const TextStyle(
              fontSize: 18,
              fontFamily: 'Fira Code',
              fontWeight: FontWeight.w500,
            ),
          )
        : ElevatedButton.styleFrom(
            backgroundColor: backgroundColor ?? const Color(0xFFE6E6E6),
            foregroundColor: textColor ?? const Color(0xFF0E0E0E),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
            minimumSize: const Size(double.infinity, 50),
            textStyle: const TextStyle(
              fontSize: 18,
              fontFamily: 'Fira Code',
              fontWeight: FontWeight.w500,
            ),
          );

    return SizedBox(
      width: double.infinity,
      child: isOutlined
          ? OutlinedButton(onPressed: onPressed, style: style, child: Text(text))
          : ElevatedButton(onPressed: onPressed, style: style, child: Text(text)),
    );
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/send_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:quantus_sdk/quantus_sdk.dart';
import 'package:resonance_network_wallet/features/main/screens/send_progress_overlay.dart';
import 'package:resonance_network_wallet/features/main/screens/qr_scanner_screen.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'dart:async';

class SendScreen extends StatefulWidget {
  const SendScreen({super.key});

  @override
  SendScreenState createState() => SendScreenState();
}

class SendScreenState extends State<SendScreen> {
  final TextEditingController _recipientController = TextEditingController();
  final TextEditingController _amountController = TextEditingController();
  final NumberFormattingService _formattingService = NumberFormattingService();
  final SettingsService _settingsService = SettingsService();
  BigInt _maxBalance = BigInt.zero;
  BigInt _networkFee = BigInt.zero; // Actual network fee fetched from chain
  bool _isFetchingFee = false;
  BigInt _amount = BigInt.zero;
  bool _hasAddressError = false;
  bool _hasAmountError = false;
  String _savedAddressesLabel = '';
  Timer? _debounce;

  late Future<BigInt> _balanceFuture;

  @override
  void initState() {
    super.initState();
    _balanceFuture = _loadBalance();
    // Listen for changes in recipient and amount to update fee
    _recipientController.addListener(_debounceFetchFee);
    _amountController.addListener(_debounceFetchFee);
  }

  @override
  void dispose() {
    _debounce?.cancel();
    _amountController.dispose();
    _recipientController.dispose();
    super.dispose();
  }

  bool _isValidSS58Address(String address) {
    try {
      return SubstrateService().isValidSS58Address(address);
    } catch (e) {
      debugPrint('Error validating address: $e');
      return false;
    }
  }

  Future<BigInt> _loadBalance() async {
    try {
      final accountId = await _settingsService.getAccountId();

      if (accountId == null) {
        throw Exception('Wallet not found');
      }

      final balance = await SubstrateService().queryBalance(accountId);
      return balance;
    } catch (e) {
      debugPrint('Error loading balance: $e');
      rethrow;
    }
  }

  Future<void> _lookupIdentity() async {
    if (!mounted) return; // Add early return if not mounted
    final recipient = _recipientController.text.trim();
    if (recipient.isEmpty) {
      if (!mounted) return; // Check mounted before setState
      setState(() {
        _savedAddressesLabel = '';
        _hasAddressError = false;
      });
      return;
    }

    try {
      final isValid = _isValidSS58Address(recipient);
      if (!mounted) return; // Check mounted before setState
      setState(() {
        _hasAddressError = !isValid;
      });

      if (isValid) {
        print('Starting wallet name lookup for: $recipient');
        final humanReadableName = await HumanReadableChecksumService().getHumanReadableName(recipient);
        print('Final humanReadableName: $humanReadableName');
        if (!mounted) return; // Check mounted before setState
        setState(() {
          _savedAddressesLabel = humanReadableName;
        });
      } else {
        if (!mounted) return; // Check mounted before setState
        setState(() {
          _savedAddressesLabel = '';
        });
      }
    } catch (e) {
      debugPrint('Error in identity lookup: $e');
      if (!mounted) return; // Check mounted before setState
      setState(() {
        _savedAddressesLabel = '';
        _hasAddressError = true;
      });
    }
  }

  void _validateAmount(String value) {
    if (value.isEmpty) {
      setState(() {
        _amount = BigInt.zero;
        _hasAmountError = false;
        _networkFee = BigInt.zero;
      });
      return;
    }

    final parsedAmount = _formattingService.parseAmount(value);

    if (parsedAmount == null) {
      setState(() {
        _amount = BigInt.zero;
        _hasAmountError = true;
        _networkFee = BigInt.zero;
      });
    } else {
      setState(() {
        _amount = parsedAmount;
        // Simplified check; full check including fee happens after fetching fee
        _hasAmountError = _amount <= BigInt.zero || _amount > _maxBalance; // Basic validation
      });
      _debounceFetchFee(); // Trigger fee fetch after amount validation
    }
  }

  void _debounceFetchFee() {
    if (_debounce?.isActive ?? false) _debounce!.cancel();
    _debounce = Timer(const Duration(milliseconds: 500), () {
      _fetchNetworkFee();
    });
  }

  Future<void> _fetchNetworkFee() async {
    final recipient = _recipientController.text.trim();
    if (!_isValidSS58Address(recipient) || _amount <= BigInt.zero || (_networkFee > BigInt.zero)) {
      setState(() {
        _networkFee = _networkFee;
        _isFetchingFee = false;
        _hasAmountError = _amount > BigInt.zero && (_amount + _networkFee) > _maxBalance;
      });
      return;
    }

    try {
      final senderAccountId = await _settingsService.getAccountId();
      if (senderAccountId == null) {
        throw Exception('Sender account not found');
      }
      final dummyAmountForFee = BigInt.from(1) * NumberFormattingService.scaleFactorBigInt; // Use a minimal amount
      final estimatedFee = await SubstrateService().getFee(senderAccountId, recipient, dummyAmountForFee);

      setState(() {
        _networkFee = estimatedFee;
        _isFetchingFee = false;
        _hasAmountError = (_amount + _networkFee) > _maxBalance;
      });
    } catch (e) {
      debugPrint('Error fetching network fee: $e');
      setState(() {
        _networkFee = BigInt.zero;
        _isFetchingFee = false;
        _hasAmountError = _amount <= BigInt.zero || _amount > _maxBalance;
      });
      if (mounted) {
        showTopSnackBar(context, title: 'Error', message: 'Error fetching network fee: ${e.toString()}');
      }
    }
  }

  void _setMaxAmount() {
    final maxSendableAmount = _maxBalance - _networkFee;
    if (maxSendableAmount > BigInt.zero) {
      final formattedMax = _formattingService.formatBalance(maxSendableAmount);
      _amountController.text = formattedMax;
      _validateAmount(formattedMax);
    } else {
      _amountController.text = '0';
      _validateAmount('0');
    }
  }

  void _showSendConfirmation() {
    debugPrint('Showing confirmation for amount (BigInt): $_amount');

    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (context) => SendConfirmationOverlay(
        amount: _amount,
        recipientName: _savedAddressesLabel,
        recipientAddress: _recipientController.text,
        fee: _networkFee,
        onClose: () => Navigator.pop(context),
      ),
    );
  }

  Future<void> _scanQRCode() async {
    print('Scanning QR code');
    final scannedAddress = await Navigator.push<String>(
      context,
      MaterialPageRoute(
        builder: (context) => const QRScannerScreen(),
        fullscreenDialog: true,
      ),
    );

    if (scannedAddress != null && mounted) {
      _recipientController.text = scannedAddress;
      // Add a small delay to ensure the text controller has updated
      // await Future.delayed(const Duration(milliseconds: 100));
      if (mounted) {
        _lookupIdentity();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF0E0E0E),
      body: Stack(
        children: [
          Positioned.fill(
            child: Opacity(
              opacity: 0.54,
              child: Image.asset(
                'assets/light_leak_effect_background.jpg',
                fit: BoxFit.cover,
              ),
            ),
          ),
          SafeArea(
            child: FutureBuilder<BigInt>(
              future: _balanceFuture,
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator(color: Colors.white));
                }

                if (snapshot.hasError) {
                  return Center(
                    child: Padding(
                      padding: const EdgeInsets.all(20.0),
                      child: Text(
                        'Error loading balance: ${snapshot.error}',
                        style: const TextStyle(color: Colors.redAccent, fontSize: 16),
                        textAlign: TextAlign.center,
                      ),
                    ),
                  );
                }

                if (snapshot.hasData) {
                  _maxBalance = snapshot.data!;

                  return Column(
                    children: [
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                        child: Row(
                          children: [
                            GestureDetector(
                              onTap: () => Navigator.pop(context),
                              child: const Icon(
                                Icons.arrow_back,
                                color: Colors.white,
                                size: 24,
                              ),
                            ),
                            const SizedBox(width: 4),
                            const Text(
                              'Send',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                                fontFamily: 'Fira Code',
                                fontWeight: FontWeight.w400,
                              ),
                            ),
                          ],
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        child: Container(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          child: Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Expanded(
                                child: Row(
                                  children: [
                                    const Text(
                                      'To:',
                                      style: TextStyle(
                                        color: Colors.white,
                                        fontSize: 14,
                                        fontFamily: 'Fira Code',
                                        fontWeight: FontWeight.w400,
                                      ),
                                    ),
                                    Container(
                                      width: 1,
                                      height: 17,
                                      color: Colors.white,
                                      margin: const EdgeInsets.symmetric(horizontal: 2),
                                    ),
                                    Expanded(
                                      child: TextField(
                                        controller: _recipientController,
                                        style: const TextStyle(
                                          color: Colors.white,
                                          fontSize: 14,
                                          fontFamily: 'Fira Code',
                                          fontWeight: FontWeight.w400,
                                        ),
                                        decoration: InputDecoration(
                                          border: InputBorder.none,
                                          enabledBorder: _hasAddressError
                                              ? const OutlineInputBorder(
                                                  borderSide: BorderSide(color: Colors.red, width: 1),
                                                )
                                              : InputBorder.none,
                                          focusedBorder: _hasAddressError
                                              ? const OutlineInputBorder(
                                                  borderSide: BorderSide(color: Colors.red, width: 1),
                                                )
                                              : InputBorder.none,
                                          hintText: '${AppConstants.tokenSymbol} address',
                                          hintStyle: TextStyle(
                                            color: Colors.white.useOpacity(0.3),
                                            fontSize: 14,
                                            fontFamily: 'Fira Code',
                                            fontWeight: FontWeight.w300,
                                            letterSpacing: 0.5,
                                          ),
                                          isDense: true,
                                          contentPadding: EdgeInsets.zero,
                                          filled: true,
                                          fillColor: Colors.transparent,
                                        ),
                                        autocorrect: false,
                                        enableSuggestions: false,
                                        enableInteractiveSelection: true,
                                        keyboardType: TextInputType.text,
                                        textCapitalization: TextCapitalization.none,
                                        onChanged: (value) {
                                          if (_debounce?.isActive ?? false) _debounce?.cancel();
                                          _debounce = Timer(const Duration(milliseconds: 300), () {
                                            _lookupIdentity();
                                          });
                                        },
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                              Row(
                                children: [
                                  GestureDetector(
                                    onTap: _scanQRCode,
                                    child: _buildIconButton('assets/scan.svg'),
                                  ),
                                  const SizedBox(width: 9),
                                  GestureDetector(
                                    onTap: () async {
                                      final data = await Clipboard.getData('text/plain');
                                      if (data != null && data.text != null) {
                                        _recipientController.text = data.text!;
                                        _lookupIdentity();
                                      }
                                    },
                                    child: _buildIconButton('assets/paste_icon.svg'),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        ),
                      ),
                      Align(
                        alignment: Alignment.centerLeft,
                        child: Padding(
                          padding: const EdgeInsets.only(left: 16),
                          child: Text(
                            _savedAddressesLabel,
                            style: TextStyle(
                              color: Colors.white.useOpacity(0.8),
                              fontSize: 13,
                              fontFamily: 'Fira Code',
                              fontWeight: FontWeight.w500,
                              decoration: TextDecoration.underline,
                            ),
                          ),
                        ),
                      ),
                      Expanded(
                        child: Center(
                          child: Row(
                            mainAxisAlignment: MainAxisAlignment.center,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              IntrinsicWidth(
                                child: TextField(
                                  controller: _amountController,
                                  textAlign: TextAlign.end,
                                  style: const TextStyle(
                                    color: Colors.white,
                                    fontSize: 40,
                                    fontFamily: 'Fira Code',
                                    fontWeight: FontWeight.w600,
                                  ),
                                  decoration: InputDecoration(
                                    border: InputBorder.none,
                                    enabledBorder: _hasAmountError
                                        ? OutlineInputBorder(
                                            borderSide: const BorderSide(color: Colors.red, width: 1),
                                            borderRadius: BorderRadius.circular(5),
                                          )
                                        : InputBorder.none,
                                    focusedBorder: _hasAmountError
                                        ? OutlineInputBorder(
                                            borderSide: const BorderSide(color: Colors.red, width: 1.5),
                                            borderRadius: BorderRadius.circular(5),
                                          )
                                        : InputBorder.none,
                                    hintText: '0',
                                    hintStyle: TextStyle(
                                      color: Colors.white.useOpacity(0.5),
                                      fontSize: 40,
                                      fontFamily: 'Fira Code',
                                      fontWeight: FontWeight.w600,
                                    ),
                                    isDense: true,
                                    contentPadding: EdgeInsets.zero,
                                    filled: true,
                                    fillColor: Colors.transparent,
                                  ),
                                  keyboardType: const TextInputType.numberWithOptions(decimal: true),
                                  inputFormatters: [
                                    FilteringTextInputFormatter.allow(RegExp(r'^\d*\.?\d*')),
                                  ],
                                  onChanged: _validateAmount,
                                ),
                              ),
                              const Text(
                                ' ${AppConstants.tokenSymbol}',
                                style: TextStyle(
                                  color: Colors.white,
                                  fontSize: 19,
                                  fontFamily: 'Fira Code',
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text(
                              'Available: ${_formattingService.formatBalance(_maxBalance)}',
                              style: const TextStyle(
                                color: Color(0xFF16CECE),
                                fontSize: 14,
                                fontFamily: 'Fira Code',
                                fontWeight: FontWeight.w500,
                              ),
                            ),
                            Container(
                              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                              decoration: ShapeDecoration(
                                color: Colors.white.useOpacity(0.15),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(4),
                                ),
                              ),
                              child: GestureDetector(
                                onTap: _setMaxAmount,
                                child: const Text(
                                  'Max',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 12,
                                    fontFamily: 'Fira Code',
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(height: 24),
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  'Network fee',
                                  style: TextStyle(
                                    color: Colors.white.useOpacity(0.6),
                                    fontSize: 12,
                                    fontFamily: 'Fira Code',
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                                Row(
                                  children: [
                                    Text(
                                      '${_formattingService.formatBalance(_networkFee)} ${AppConstants.tokenSymbol}',
                                      style: const TextStyle(
                                        color: Colors.white,
                                        fontSize: 12,
                                        fontFamily: 'Fira Code',
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                    if (_isFetchingFee)
                                      const Padding(
                                        padding: EdgeInsets.only(left: 8.0),
                                        child: SizedBox(
                                          width: 12,
                                          height: 12,
                                          child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white70),
                                        ),
                                      ),
                                  ],
                                ),
                              ],
                            ),
                            _buildIconButton('assets/settings_icon.svg'),
                          ],
                        ),
                      ),
                      const SizedBox(height: 24),
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        child: GestureDetector(
                          onTap: (_hasAddressError ||
                                  _hasAmountError ||
                                  _recipientController.text.isEmpty ||
                                  _amount <= BigInt.zero ||
                                  _isFetchingFee)
                              ? null
                              : _showSendConfirmation,
                          child: Opacity(
                            opacity: (_hasAddressError ||
                                    _hasAmountError ||
                                    _recipientController.text.isEmpty ||
                                    _amount <= BigInt.zero ||
                                    _isFetchingFee)
                                ? 0.3
                                : 1.0,
                            child: Container(
                              width: double.infinity,
                              padding: const EdgeInsets.all(16),
                              decoration: ShapeDecoration(
                                color: Colors.white,
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(5),
                                ),
                              ),
                              child: Text(
                                (_hasAddressError || _recipientController.text.isEmpty)
                                    ? 'Enter Address'
                                    : (_amount <= BigInt.zero)
                                        ? 'Enter Amount'
                                        : _hasAmountError
                                            ? 'Insufficient Balance'
                                            : 'Send ${_formattingService.formatBalance(_amount)} ${AppConstants.tokenSymbol}',
                                textAlign: TextAlign.center,
                                style: const TextStyle(
                                  color: Color(0xFF0E0E0E),
                                  fontSize: 18,
                                  fontFamily: 'Fira Code',
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ),
                          ),
                        ),
                      ),
                      const SizedBox(height: 24),
                    ],
                  );
                }

                return const SizedBox();
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildIconButton(String assetPath) {
    return Container(
      padding: const EdgeInsets.all(4),
      decoration: ShapeDecoration(
        color: Colors.white.useOpacity(0.15),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(4),
        ),
      ),
      child: SvgPicture.asset(
        assetPath,
        width: 17,
        height: 17,
      ),
    );
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/wallet_initializer.dart ---
import 'package:flutter/material.dart';
import 'package:resonance_network_wallet/features/main/screens/wallet_main.dart';
import 'package:resonance_network_wallet/features/main/screens/welcome_screen.dart';
import 'package:quantus_sdk/quantus_sdk.dart';

class WalletInitializer extends StatefulWidget {
  const WalletInitializer({super.key});

  @override
  WalletInitializerState createState() => WalletInitializerState();
}

class WalletInitializerState extends State<WalletInitializer> {
  bool _loading = true;
  bool _walletExists = false;
  final SettingsService _settingsService = SettingsService();

  @override
  void initState() {
    super.initState();
    _checkWalletExists();
  }

  Future<void> _checkWalletExists() async {
    final hasWallet = await _settingsService.getHasWallet();

    setState(() {
      _walletExists = hasWallet;
      _loading = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_loading) {
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    if (_walletExists) {
      return const WalletMain();
    } else {
      return const WelcomeScreen();
    }
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/import_wallet_screen.dart ---
import 'package:flutter/material.dart';
import 'package:quantus_sdk/quantus_sdk.dart';
import 'package:resonance_network_wallet/features/main/screens/wallet_main.dart';
import 'package:flutter/services.dart';

class ImportWalletScreen extends StatefulWidget {
  const ImportWalletScreen({super.key});

  @override
  ImportWalletScreenState createState() => ImportWalletScreenState();
}

class ImportWalletScreenState extends State<ImportWalletScreen> {
  final TextEditingController _mnemonicController = TextEditingController();
  bool _isLoading = false;
  String _errorMessage = '';
  final SettingsService _settingsService = SettingsService();

  Future<void> _importWallet() async {
    setState(() {
      _isLoading = true;
      _errorMessage = '';
    });

    try {
      final input = _mnemonicController.text.trim();

      // Check if it's a derivation path
      if (input.startsWith('//')) {
        // No validation needed for derivation paths
        debugPrint('Using derivation path: $input');
      } else {
        // Validate mnemonic
        final words = input.split(' ').where((word) => word.isNotEmpty).toList();
        if (words.length != 12 && words.length != 24) {
          throw Exception('Mnemonic must be 12 or 24 words');
        }
      }

      final walletInfo = await SubstrateService().generateWalletFromSeed(input);
      // Save wallet info
      await _settingsService.setHasWallet(true);
      await _settingsService.setMnemonic(input);
      await _settingsService.setAccountId(walletInfo.accountId);

      if (context.mounted && mounted) {
        Navigator.pushAndRemoveUntil(
          context,
          MaterialPageRoute(builder: (context) => const WalletMain()),
          (route) => false,
        );
      }
    } catch (e) {
      setState(() {
        _errorMessage = e.toString();
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF0E0E0E),
      body: Container(
        decoration: const BoxDecoration(
          image: DecorationImage(
            image: AssetImage('assets/light_leak_effect_background.jpg'), // Assuming this is the correct background
            fit: BoxFit.cover,
            opacity: 0.54,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch, // Stretch children horizontally
              children: [
                // Back button row remains at the top
                Row(
                  children: [
                    IconButton(
                      icon: const Icon(Icons.arrow_back, color: Colors.white),
                      onPressed: () => Navigator.pop(context),
                      padding: EdgeInsets.zero,
                      constraints: const BoxConstraints(),
                    ),
                  ],
                ),
                const SizedBox(height: 40),
                // Content previously inside Center/nested Column
                const Text(
                  'Import Wallet',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 18,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 13),
                Text(
                  'Restore an existing wallet with your 12 or 24 word recovery phrase',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color: Colors.white.useOpacity(0.6),
                    fontSize: 14,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w500,
                    height: 1.21,
                  ),
                ),
                const SizedBox(height: 21),
                Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Expanded(
                      child: TextField(
                        controller: _mnemonicController,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 13,
                          fontFamily: 'Fira Code',
                          fontWeight: FontWeight.w400,
                        ),
                        decoration: InputDecoration(
                          filled: true,
                          fillColor: Colors.black.useOpacity(0.5),
                          contentPadding: const EdgeInsets.all(13),
                          border: OutlineInputBorder(
                            borderSide: const BorderSide(color: Color(0xFF9F7AEA), width: 1),
                            borderRadius: BorderRadius.circular(5),
                          ),
                          enabledBorder: OutlineInputBorder(
                            borderSide: BorderSide(
                              width: 1,
                              color: const Color(0xFF9F7AEA).useOpacity(0.8),
                            ),
                            borderRadius: BorderRadius.circular(5),
                          ),
                          focusedBorder: OutlineInputBorder(
                            borderSide: const BorderSide(color: Color(0xFF9F7AEA), width: 1.5),
                            borderRadius: BorderRadius.circular(5),
                          ),
                          hintText: 'Type in or paste your recovery phrase. Separate words with spaces',
                          hintStyle: TextStyle(
                            color: Colors.white.useOpacity(0.5),
                            fontSize: 13,
                            fontFamily: 'Fira Code',
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                        maxLines: null,
                        minLines: 6,
                        keyboardType: TextInputType.multiline,
                        textInputAction: TextInputAction.done,
                      ),
                    ),
                    const SizedBox(width: 8),
                    IconButton(
                      icon: const Icon(Icons.paste, color: Colors.white70),
                      onPressed: () async {
                        final data = await Clipboard.getData('text/plain');
                        if (data != null && data.text != null) {
                          _mnemonicController.text = data.text!;
                        }
                      },
                      tooltip: 'Paste',
                    ),
                  ],
                ),
                // Padding(
                //   padding: const EdgeInsets.only(top: 12.0, bottom: 8.0),
                //   child: Theme(
                //     data: Theme.of(context).copyWith(
                //       unselectedWidgetColor: Colors.white70,
                //     ),
                //     // child: CheckboxListTile(
                //     //   title: const Text(
                //     //     'Import Crystal Alice test account',
                //     //     style: TextStyle(
                //     //       color: Colors.white70,
                //     //       fontSize: 13,
                //     //       fontFamily: 'Fira Code',
                //     //     ),
                //     //   ),
                //     //   value: _mnemonicController.text == crystalAlice,
                //     //   onChanged: (bool? value) {
                //     //     setState(() {
                //     //       if (value == true) {
                //     //         _mnemonicController.text = crystalAlice;
                //     //         _errorMessage = '';
                //     //       } else {
                //     //         if (_mnemonicController.text == crystalAlice) {
                //     //           _mnemonicController.clear();
                //     //         }
                //     //       }
                //     //     });
                //     //   },
                //     //   activeColor: const Color(0xFF9F7AEA),
                //     //   controlAffinity: ListTileControlAffinity.leading,
                //     //   contentPadding: EdgeInsets.zero,
                //     //   dense: true,
                //     // ),
                //   ),
                // ),
                if (_errorMessage.isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0, bottom: 8.0), // Added bottom padding
                    child: Text(
                      _errorMessage,
                      style: const TextStyle(color: Colors.red, fontSize: 12),
                      textAlign: TextAlign.center,
                    ),
                  ),
                const Spacer(), // Add Spacer to push the button down
                GradientActionButton(
                  label: 'Import Wallet',
                  onPressed: _importWallet,
                  isLoading: _isLoading,
                ),
                const SizedBox(height: 24), // Consistent bottom padding like CreateWalletScreen
              ],
            ),
          ),
        ),
      ),
    );
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/wallet_main.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'dart:io';
import 'dart:async';
import 'package:resonance_network_wallet/features/main/screens/account_profile.dart';
import 'package:quantus_sdk/quantus_sdk.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:resonance_network_wallet/features/main/screens/receive_screen.dart';
import 'package:resonance_network_wallet/features/main/screens/welcome_screen.dart';

class WalletData {
  final String accountId;
  final String walletName;
  final BigInt balance;

  WalletData({required this.accountId, required this.walletName, required this.balance});
}

class WalletMain extends StatefulWidget {
  const WalletMain({super.key});

  @override
  State<WalletMain> createState() => _WalletMainState();
}

class _WalletMainState extends State<WalletMain> {
  final SubstrateService _substrateService = SubstrateService();
  final NumberFormattingService _formattingService = NumberFormattingService();
  final SettingsService _settingsService = SettingsService();
  final ChainHistoryService _chainHistoryService = ChainHistoryService();

  Future<WalletData?>? _walletDataFuture;
  String? _accountId;
  List<Transfer> _transfers = [];
  bool _isHistoryLoading = true;
  String? _historyError;

  // Pagination state
  int _toOffset = 0;
  int _fromOffset = 0;
  bool _hasMoreTo = true;
  bool _hasMoreFrom = true;
  bool _isLoadingMore = false;
  static const int _transactionsPerPage = 10;
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _loadWalletDataAndSetFuture();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent - 200) {
      _loadMoreTransactions();
    }
  }

  void _loadWalletDataAndSetFuture() {
    setState(() {
      _walletDataFuture = _loadWalletDataInternal();
    });
  }

  Future<WalletData?> _loadWalletDataInternal() async {
    String? accountId;
    BigInt? balance;
    const Duration networkTimeout = Duration(seconds: 15);

    try {
      accountId = await _settingsService.getAccountId();

      if (accountId == null || accountId.isEmpty) {
        throw Exception('Account ID not found');
      }
      _accountId = accountId;

      print('Attempting initial balance query for $accountId...');
      balance = await _substrateService.queryBalance(accountId).timeout(networkTimeout);
      print('Initial balance query successful.');

      // Fetch transaction history after successful wallet data load
      await _fetchTransactionHistory();
    } catch (e) {
      print('Initial load/query failed: $e');

      bool isConnectionError = e is SocketException ||
          e is TimeoutException ||
          e.toString().contains('Connection refused') ||
          e.toString().contains('WebSocket');

      if (isConnectionError && accountId != null) {
        print('Connection error detected. Attempting reconnect and retry...');
        try {
          await _substrateService.reconnect();
          balance = await _substrateService.queryBalance(accountId).timeout(networkTimeout);
          print('Balance query successful after reconnect.');
        } catch (retryError) {
          print('Retry failed after reconnect: $retryError');
          throw Exception('Failed to load wallet data after retry: $retryError');
        }
      } else {
        print('Error was not connection-related or accountId is null. Rethrowing.');
        throw Exception('Failed to load wallet data: $e');
      }
    }

    return WalletData(accountId: accountId, walletName: '', balance: balance);
  }

  Future<void> _loadMoreTransactions() async {
    if ((!_hasMoreTo && !_hasMoreFrom) || _isLoadingMore || _isHistoryLoading) return;

    setState(() {
      _isLoadingMore = true;
    });

    try {
      final result = await _chainHistoryService.fetchTransfers(
        accountId: _accountId!,
        limit: _transactionsPerPage,
        toOffset: _toOffset,
        fromOffset: _fromOffset,
      );

      setState(() {
        _transfers = [..._transfers, ...result.combinedTransfers];
        _hasMoreTo = result.hasMoreTo;
        _hasMoreFrom = result.hasMoreFrom;
        _toOffset = result.nextToOffset;
        _fromOffset = result.nextFromOffset;
        _isLoadingMore = false;
      });
    } catch (e) {
      setState(() {
        _isLoadingMore = false;
        _historyError = 'Failed to load more transactions.';
      });
    }
  }

  Future<void> _fetchTransactionHistory() async {
    print('fetchTransactionHistory: $_accountId');
    if (_accountId == null) return;

    setState(() {
      _isHistoryLoading = true;
      _historyError = null;
      _toOffset = 0;
      _fromOffset = 0;
      _hasMoreTo = true;
      _hasMoreFrom = true;
      _transfers = [];
    });

    try {
      final result = await _chainHistoryService.fetchTransfers(
        accountId: _accountId!,
        limit: _transactionsPerPage,
        toOffset: 0,
        fromOffset: 0,
      );

      setState(() {
        _transfers = result.combinedTransfers;
        _hasMoreTo = result.hasMoreTo;
        _hasMoreFrom = result.hasMoreFrom;
        _toOffset = result.nextToOffset;
        _fromOffset = result.nextFromOffset;
        _isHistoryLoading = false;
      });
      print('fetchedTransfers: ${_transfers.length}');
    } catch (e) {
      print('Error fetching transaction history: $e');
      setState(() {
        _historyError = 'Failed to load transaction history.';
        _isHistoryLoading = false;
      });
    }
  }

  // Helper to format the address (now just returns the full address)
  String _formatAddress(String address) {
    return address; // Return the full address, let Text widget handle overflow
  }

  Widget _buildActionButton({
    required Widget iconWidget,
    required String label,
    required Color borderColor,
    required VoidCallback onPressed,
    bool disabled = false,
  }) {
    final color = disabled ? Colors.white.useOpacity(0.5) : Colors.white;
    final bgColor = Colors.black.useOpacity(166 / 255.0);
    final effectiveBorderColor = disabled ? borderColor.useOpacity(0.5) : borderColor;

    Widget finalIconWidget = iconWidget;
    if (iconWidget is SvgPicture) {
      finalIconWidget = SvgPicture.asset(
        (iconWidget.bytesLoader as SvgAssetLoader).assetName,
        width: 20,
        height: 20,
      );
    } else if (iconWidget is Icon) {
      finalIconWidget = Icon(
        iconWidget.icon,
        color: color,
        size: 20,
      );
    } else if (iconWidget is Image) {
      finalIconWidget = SizedBox(
        width: 20,
        height: 20,
        child: iconWidget,
      );
    }

    return Opacity(
      opacity: disabled ? 0.7 : 1.0,
      child: InkWell(
        onTap: disabled ? null : onPressed,
        borderRadius: BorderRadius.circular(4),
        child: Container(
          width: 65,
          height: 56,
          padding: const EdgeInsets.symmetric(vertical: 8),
          decoration: ShapeDecoration(
            color: bgColor,
            shape: RoundedRectangleBorder(
              side: BorderSide(width: 1, color: effectiveBorderColor),
              borderRadius: BorderRadius.circular(4),
            ),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              finalIconWidget,
              const SizedBox(height: 4),
              Text(
                label,
                textAlign: TextAlign.center,
                style: TextStyle(
                  color: color,
                  fontSize: 10,
                  fontFamily: 'Inter',
                  fontWeight: FontWeight.w300,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTransactionItem({
    required String type,
    required String amount,
    required String details,
    required Widget iconWidget,
    required Color typeColor,
    required String rawTimestamp,
  }) {
    final String iconAsset;
    final Color effectiveTypeColor;
    if (type == 'Sent') {
      iconAsset = 'assets/send_icon_1.svg';
      effectiveTypeColor = const Color(0xFF16CECE);
    } else {
      iconAsset = 'assets/receive_icon.svg';
      effectiveTypeColor = const Color(0xFFB259F2);
    }

    String formattedTimestamp = 'Invalid Timestamp';
    try {
      final dateTime = DateTime.parse(rawTimestamp).toLocal();
      final day = dateTime.day.toString().padLeft(2, '0');
      final month = dateTime.month.toString().padLeft(2, '0');
      final year = dateTime.year;
      final hour = dateTime.hour.toString().padLeft(2, '0');
      final minute = dateTime.minute.toString().padLeft(2, '0');
      final second = dateTime.second.toString().padLeft(2, '0');
      formattedTimestamp = '$day-$month-$year $hour:$minute:$second';
    } catch (e) {
      print('Error formatting timestamp $rawTimestamp: $e');
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      mainAxisAlignment: MainAxisAlignment.start,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          mainAxisAlignment: MainAxisAlignment.start,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            SizedBox(
              width: 21,
              height: 17,
              child: SvgPicture.asset(
                iconAsset,
                colorFilter: ColorFilter.mode(effectiveTypeColor, BlendMode.srcIn),
              ),
            ),
            const SizedBox(width: 11),
            Expanded(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text.rich(
                    TextSpan(
                      children: [
                        TextSpan(
                          text: type,
                          style: TextStyle(
                            color: effectiveTypeColor,
                            fontSize: 14,
                            fontFamily: 'Fira Code',
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                        TextSpan(
                          text: ' $amount',
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 14,
                            fontFamily: 'Fira Code',
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 5),
                  Text(
                    '$details | $formattedTimestamp',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 11,
                      fontFamily: 'Fira Code',
                      fontWeight: FontWeight.w300,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        const SizedBox(height: 14),
        Divider(
          color: Colors.white.useOpacity(38 / 255.0),
          height: 1,
        ),
        const SizedBox(height: 14),
      ],
    );
  }

  Widget _buildHistorySection() {
    if (_isHistoryLoading) {
      return const Center(
        child: CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF0CE6ED)),
        ),
      );
    }

    if (_historyError != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              _historyError!,
              style: const TextStyle(color: Colors.white70),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 10),
            TextButton(
              onPressed: _fetchTransactionHistory,
              child: const Text('Retry'),
            ),
          ],
        ),
      );
    }

    if (_transfers.isEmpty) {
      return const Center(
        child: Text(
          'No transactions yet',
          style: TextStyle(color: Colors.white70),
        ),
      );
    }

    return Column(
      children: [
        ..._transfers.map((transfer) {
          final isSend = transfer.from == _accountId;
          final type = isSend ? 'Sent' : 'Received';
          final details = isSend ? 'to ${_formatAddress(transfer.to)}' : 'from ${_formatAddress(transfer.from)}';
          final amountDisplay =
              '${isSend ? '-' : '+'}${_formattingService.formatBalance(BigInt.parse(transfer.amount))} ${AppConstants.tokenSymbol}';

          return _buildTransactionItem(
            type: type,
            amount: amountDisplay,
            details: details,
            iconWidget: Container(),
            typeColor: Colors.transparent,
            rawTimestamp: transfer.timestamp,
          );
        }),
        if (_isLoadingMore)
          const Padding(
            padding: EdgeInsets.all(16.0),
            child: Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF0CE6ED)),
              ),
            ),
          ),
        if (!_hasMoreTo && !_hasMoreFrom && _transfers.isNotEmpty)
          const Padding(
            padding: EdgeInsets.all(16.0),
            child: Text(
              'No more transactions',
              style: TextStyle(color: Colors.white70),
              textAlign: TextAlign.center,
            ),
          ),
      ],
    );
  }

  Future<void> _logout() async {
    try {
      await _substrateService.logout();
      if (mounted) {
        Navigator.pushAndRemoveUntil(
          context,
          MaterialPageRoute(builder: (context) => const WelcomeScreen()),
          (route) => false,
        );
      }
    } catch (e) {
      print('Error during logout: $e');
      if (mounted) {
        showTopSnackBar(
          context,
          title: 'Error',
          message: 'Logout failed: ${e.toString()}',
          icon: buildErrorIcon(),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF0E0E0E),
      body: Container(
        decoration: const BoxDecoration(
          image: DecorationImage(
            image: AssetImage('assets/light_leak_effect_background.jpg'),
            fit: BoxFit.cover,
            opacity: 0.54,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24.0),
            child: FutureBuilder<WalletData?>(
              future: _walletDataFuture,
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator(color: Colors.white));
                }
                if (snapshot.hasError || !snapshot.hasData || snapshot.data == null) {
                  return Column(
                    children: [
                      Expanded(
                        child: Center(
                          child: Padding(
                            padding: const EdgeInsets.symmetric(horizontal: 20.0),
                            child: Column(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                const Icon(Icons.error_outline, color: Colors.red, size: 50),
                                const SizedBox(height: 20),
                                const Text(
                                  'Failed to Connect',
                                  style: TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold),
                                  textAlign: TextAlign.center,
                                ),
                                const SizedBox(height: 10),
                                Text(
                                  'Could not load wallet data. Please check your network connection and try again.',
                                  style: TextStyle(color: Colors.white.useOpacity(0.7), fontSize: 14),
                                  textAlign: TextAlign.center,
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.only(bottom: 16.0, top: 16.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.stretch,
                          children: [
                            _buildFullWidthActionButton(
                              label: 'Retry',
                              onTap: _loadWalletDataAndSetFuture,
                              gradient: const LinearGradient(
                                begin: Alignment(0.50, 0.00),
                                end: Alignment(0.50, 1.00),
                                colors: [Color(0xFF0CE6ED), Color(0xFF8AF9A8)],
                              ),
                            ),
                            const SizedBox(height: 15),
                            _buildFullWidthActionButton(
                              label: 'Logout',
                              onTap: _logout,
                              backgroundColor: Colors.white.useOpacity(0.2),
                              textColor: Colors.white.useOpacity(0.8),
                            ),
                          ],
                        ),
                      ),
                    ],
                  );
                }

                final walletData = snapshot.data!;
                final displayAddress = _formatAddress(walletData.accountId);

                return RefreshIndicator(
                  onRefresh: () async {
                    _loadWalletDataAndSetFuture();
                    await _walletDataFuture;
                  },
                  color: const Color(0xFF0CE6ED),
                  backgroundColor: Colors.black,
                  child: CustomScrollView(
                    controller: _scrollController,
                    physics: const AlwaysScrollableScrollPhysics(),
                    slivers: [
                      SliverToBoxAdapter(
                        child: Column(
                          children: [
                            Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                SvgPicture.asset('assets/quantus_logo_hz.svg', height: 40),
                                IconButton(
                                  icon: SvgPicture.asset('assets/wallet_icon.svg', width: 24, height: 24),
                                  onPressed: () {
                                    if (_accountId != null) {
                                      Navigator.push(
                                        context,
                                        MaterialPageRoute(
                                          builder: (context) => AccountProfilePage(currentAccountId: _accountId!),
                                        ),
                                      );
                                    }
                                  },
                                ),
                              ],
                            ),
                            const SizedBox(height: 40),
                            Column(
                              crossAxisAlignment: CrossAxisAlignment.center,
                              children: [
                                InkWell(
                                  onTap: () {
                                    if (_accountId != null) {
                                      Clipboard.setData(ClipboardData(text: _accountId!));
                                      showTopSnackBar(
                                        context,
                                        title: 'Copied!',
                                        message: 'Account ID copied to clipboard',
                                      );
                                    }
                                  },
                                  borderRadius: BorderRadius.circular(5),
                                  child: Container(
                                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 5),
                                    child: Row(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        Image.asset(
                                          'assets/active_dot.png',
                                          width: 20,
                                          height: 20,
                                        ),
                                        const SizedBox(width: 8),
                                        Expanded(
                                          child: Container(
                                            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 5),
                                            decoration: ShapeDecoration(
                                              color: Colors.black.useOpacity(0.5),
                                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
                                            ),
                                            child: Text(
                                              displayAddress,
                                              textAlign: TextAlign.center,
                                              overflow: TextOverflow.ellipsis,
                                              style: const TextStyle(
                                                color: Colors.white,
                                                fontSize: 14,
                                                fontFamily: 'Fira Code',
                                                fontWeight: FontWeight.w400,
                                              ),
                                            ),
                                          ),
                                        ),
                                        const SizedBox(width: 8),
                                        const Icon(Icons.expand_more, color: Colors.white70, size: 12),
                                      ],
                                    ),
                                  ),
                                ),
                                const SizedBox(height: 7),
                                Text.rich(
                                  TextSpan(
                                    children: [
                                      TextSpan(
                                        text: _formattingService.formatBalance(walletData.balance),
                                        style: const TextStyle(
                                          color: Color(0xFFE6E6E6),
                                          fontSize: 40,
                                          fontFamily: 'Fira Code',
                                          fontWeight: FontWeight.w600,
                                        ),
                                      ),
                                      const TextSpan(
                                        text: ' ${AppConstants.tokenSymbol}',
                                        style: TextStyle(
                                          color: Color(0xFFE6E6E6),
                                          fontSize: 20,
                                          fontFamily: 'Fira Code',
                                          fontWeight: FontWeight.w600,
                                        ),
                                      ),
                                    ],
                                  ),
                                  textAlign: TextAlign.center,
                                ),
                              ],
                            ),
                            const SizedBox(height: 30),
                            Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                _buildActionButton(
                                  iconWidget: SvgPicture.asset('assets/send_icon_1.svg'),
                                  label: 'SEND',
                                  borderColor: const Color(0xFF0AD4F6),
                                  onPressed: () {
                                    Navigator.pushNamed(context, '/send');
                                  },
                                ),
                                _buildActionButton(
                                  iconWidget: SvgPicture.asset('assets/receive_icon.svg'),
                                  label: 'RECEIVE',
                                  borderColor: const Color(0xFFB258F1),
                                  onPressed: () {
                                    showReceiveSheet(context);
                                  },
                                ),
                                _buildActionButton(
                                  iconWidget: SvgPicture.asset('assets/swap_icon.svg'),
                                  label: 'SWAP',
                                  borderColor: const Color(0xFF0AD4F6),
                                  onPressed: () {},
                                  disabled: true,
                                ),
                                _buildActionButton(
                                  iconWidget: SvgPicture.asset('assets/bridge_icon.svg'),
                                  label: 'BRIDGE',
                                  borderColor: const Color(0xFF0AD4F6),
                                  onPressed: () {},
                                  disabled: true,
                                ),
                              ],
                            ),
                            const SizedBox(height: 30),
                          ],
                        ),
                      ),
                      SliverToBoxAdapter(
                        child: Container(
                          padding: const EdgeInsets.all(10),
                          decoration: ShapeDecoration(
                            color: Colors.black.withAlpha(64),
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              const Text(
                                'Recent Transactions',
                                style: TextStyle(
                                  color: Color(0xFFE6E6E6),
                                  fontSize: 14,
                                  fontFamily: 'Fira Code',
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                              const SizedBox(height: 18),
                              _buildHistorySection(),
                            ],
                          ),
                        ),
                      ),
                    ],
                  ),
                );
              },
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFullWidthActionButton({
    required String label,
    required VoidCallback onTap,
    Gradient? gradient,
    Color? backgroundColor,
    Color? textColor,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: double.infinity,
        padding: const EdgeInsets.all(16),
        decoration: ShapeDecoration(
          gradient: gradient,
          color: backgroundColor,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
        ),
        child: Center(
          child: Text(
            label,
            style: TextStyle(
              color: textColor ?? const Color(0xFF0E0E0E),
              fontSize: 18,
              fontFamily: 'Fira Code',
              fontWeight: FontWeight.w500,
            ),
          ),
        ),
      ),
    );
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/create_wallet_and_backup_screen.dart ---
import 'package:flutter/material.dart';
import 'package:quantus_sdk/quantus_sdk.dart';
import 'package:resonance_network_wallet/features/main/screens/wallet_main.dart';
import 'package:flutter/services.dart';

class CreateWalletAndBackupScreen extends StatefulWidget {
  const CreateWalletAndBackupScreen({super.key});

  @override
  CreateWalletAndBackupScreenState createState() => CreateWalletAndBackupScreenState();
}

class CreateWalletAndBackupScreenState extends State<CreateWalletAndBackupScreen> {
  String _mnemonic = '';
  bool _isLoading = true;
  bool _hasSavedMnemonic = false;
  String? _error;
  final SettingsService _settingsService = SettingsService();

  @override
  void initState() {
    super.initState();
    _generateMnemonic();
  }

  Future<void> _generateMnemonic() async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      _mnemonic = await SubstrateService().generateMnemonic();
      if (_mnemonic.isEmpty) throw Exception('Mnemonic generation returned empty.');

      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Error generating mnemonic: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
          _error = 'Failed to generate recovery phrase: $e';
        });
      }
    }
  }

  Future<void> _saveWalletAndContinue() async {
    if (_mnemonic.isEmpty) {
      debugPrint('Cannot save wallet, mnemonic is empty.');
      if (mounted) {
        showTopSnackBar(
          context,
          title: 'Error',
          message: 'Recovery phrase not generated.',
        );
      }
      return;
    }

    try {
      final walletInfo = await SubstrateService().generateWalletFromSeed(_mnemonic);

      // final walletName = await HumanReadableChecksumService().getHumanReadableName(walletInfo.accountId);
      // if (walletName.isEmpty) throw Exception('Checksum generation failed');

      await _settingsService.setHasWallet(true);
      await _settingsService.setMnemonic(_mnemonic);
      await _settingsService.setAccountId(walletInfo.accountId);

      if (context.mounted) {
        Navigator.pushAndRemoveUntil(
          context,
          MaterialPageRoute(builder: (context) => const WalletMain()),
          (route) => false,
        );
      }
    } catch (e) {
      debugPrint('Error saving wallet: $e');
      if (mounted) {
        showTopSnackBar(
          context,
          title: 'Error',
          message: 'Error saving wallet: $e',
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final words = _mnemonic.isNotEmpty ? _mnemonic.split(' ') : [];

    final bool canContinue = _hasSavedMnemonic && !_isLoading && _error == null;

    return Scaffold(
      backgroundColor: const Color(0xFF0E0E0E),
      body: Container(
        decoration: const BoxDecoration(
          image: DecorationImage(
            image: AssetImage('assets/light_leak_effect_background.jpg'),
            fit: BoxFit.cover,
            opacity: 0.54,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Row(
                  children: [
                    IconButton(
                      icon: const Icon(Icons.arrow_back, color: Colors.white),
                      onPressed: () => Navigator.pop(context),
                    ),
                    const Text(
                      'Create Wallet',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 12,
                        fontFamily: 'Fira Code',
                        fontWeight: FontWeight.w400,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                Expanded(
                  child: SingleChildScrollView(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.start,
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        const Text(
                          'Your Secret Recovery Phrase',
                          textAlign: TextAlign.center,
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 18,
                            fontFamily: 'Fira Code',
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                        const SizedBox(height: 13),
                        Text(
                          'Write down and save your seed phrase in a secure location. This is the only way to recover your wallet',
                          textAlign: TextAlign.center,
                          style: TextStyle(
                            color: Colors.white.useOpacity(153 / 255.0),
                            fontSize: 14,
                            fontFamily: 'Fira Code',
                            fontWeight: FontWeight.w500,
                            height: 1.21,
                          ),
                        ),
                        const SizedBox(height: 21),
                        if (_isLoading)
                          const Padding(
                            padding: EdgeInsets.symmetric(vertical: 50.0),
                            child: Column(
                              children: [
                                CircularProgressIndicator(color: Colors.white),
                                SizedBox(height: 16),
                                Text(
                                  'Generating secure phrase...',
                                  style: TextStyle(color: Colors.white70),
                                ),
                              ],
                            ),
                          )
                        else if (_error != null)
                          Padding(
                            padding: const EdgeInsets.symmetric(vertical: 50.0, horizontal: 20),
                            child: Text(
                              _error!,
                              style: const TextStyle(color: Colors.redAccent, fontSize: 16),
                              textAlign: TextAlign.center,
                            ),
                          )
                        else
                          Container(
                            width: double.infinity,
                            padding: const EdgeInsets.symmetric(vertical: 13, horizontal: 9),
                            decoration: ShapeDecoration(
                              color: Colors.black.useOpacity(0.7),
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
                            ),
                            child: GridView.count(
                              crossAxisCount: 3,
                              shrinkWrap: true,
                              physics: const NeverScrollableScrollPhysics(),
                              mainAxisSpacing: 10.0,
                              crossAxisSpacing: 9.0,
                              childAspectRatio: (105 / 38),
                              children: List.generate(words.length, (index) {
                                return _buildMnemonicWord(index + 1, words[index]);
                              }),
                            ),
                          ),
                        const SizedBox(height: 21),
                        if (!_isLoading && _error == null)
                          GestureDetector(
                            onTap: () {
                              Clipboard.setData(ClipboardData(text: _mnemonic));
                              showTopSnackBar(
                                context,
                                title: 'Copied!',
                                message: 'Recovery phrase copied to clipboard',
                              );
                            },
                            child: const Opacity(
                              opacity: 0.8,
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Icon(Icons.copy, color: Colors.white, size: 24),
                                  SizedBox(width: 8),
                                  Text(
                                    'Copy to Clipboard',
                                    style: TextStyle(
                                      color: Colors.white,
                                      fontSize: 14,
                                      fontFamily: 'Fira Code',
                                      fontWeight: FontWeight.w400,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ),
                        const SizedBox(height: 35),
                      ],
                    ),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.only(bottom: 16.0),
                  child: Column(
                    children: [
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          SizedBox(
                            width: 24,
                            height: 24,
                            child: Checkbox(
                              value: _hasSavedMnemonic,
                              onChanged: _isLoading
                                  ? null
                                  : (value) {
                                      setState(() {
                                        _hasSavedMnemonic = value ?? false;
                                      });
                                    },
                              activeColor: const Color(0xFF8AF9A8),
                              checkColor: const Color(0xFF8AF9A8),
                              side: WidgetStateBorderSide.resolveWith((states) {
                                return const BorderSide(width: 1, color: Colors.white);
                              }),
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(2),
                              ),
                              materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                            ),
                          ),
                          const SizedBox(width: 8),
                          const Expanded(
                            child: Text(
                              'I have copied and stored my seed phrase',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 14,
                                fontFamily: 'Fira Code',
                                fontWeight: FontWeight.w400,
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 17),
                      if (canContinue)
                        GradientActionButton(
                          label: 'Continue',
                          onPressed: _saveWalletAndContinue,
                          isLoading: _isLoading,
                        )
                      else
                        SizedBox(
                          width: double.infinity,
                          child: ElevatedButton(
                            style: ElevatedButton.styleFrom(
                              foregroundColor: Colors.grey[700],
                              backgroundColor: Colors.grey[400],
                              minimumSize: const Size(double.infinity, 50),
                              padding: const EdgeInsets.symmetric(vertical: 16),
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(5.0),
                              ),
                            ),
                            onPressed: null,
                            child: const Text(
                              'Continue',
                              style: TextStyle(
                                color: Color(0xFF0E0E0E),
                                fontSize: 18,
                                fontFamily: 'Fira Code',
                                fontWeight: FontWeight.w500,
                              ),
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildMnemonicWord(int index, String word) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6),
      decoration: ShapeDecoration(
        shape: RoundedRectangleBorder(
          side: BorderSide(
            width: 1,
            color: Colors.white.useOpacity(0.15),
          ),
          borderRadius: BorderRadius.circular(8),
        ),
      ),
      child: Text(
        '$index.$word',
        textAlign: TextAlign.center,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 12,
          fontFamily: 'Fira Code',
          fontWeight: FontWeight.w400,
        ),
      ),
    );
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/qr_scanner_screen.dart ---
import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:quantus_sdk/quantus_sdk.dart';

class QRScannerScreen extends StatefulWidget {
  const QRScannerScreen({super.key});

  @override
  State<QRScannerScreen> createState() => _QRScannerScreenState();
}

class _QRScannerScreenState extends State<QRScannerScreen> {
  final MobileScannerController controller = MobileScannerController();
  bool _hasScanned = false; // Add flag to track if we've already scanned

  @override
  void dispose() {
    controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => Navigator.pop(context),
        ),
        title: const Text(
          'Scan QR Code',
          style: TextStyle(
            color: Colors.white,
            fontSize: 18,
            fontFamily: 'Fira Code',
            fontWeight: FontWeight.w500,
          ),
        ),
        actions: [
          IconButton(
            icon: ValueListenableBuilder(
              valueListenable: controller.torchState,
              builder: (context, state, child) {
                switch (state) {
                  case TorchState.off:
                    return const Icon(Icons.flash_off, color: Colors.white);
                  case TorchState.on:
                    return const Icon(Icons.flash_on, color: Colors.white);
                }
              },
            ),
            onPressed: () => controller.toggleTorch(),
          ),
          IconButton(
            icon: ValueListenableBuilder(
              valueListenable: controller.cameraFacingState,
              builder: (context, state, child) {
                switch (state) {
                  case CameraFacing.front:
                    return const Icon(Icons.camera_front, color: Colors.white);
                  case CameraFacing.back:
                    return const Icon(Icons.camera_rear, color: Colors.white);
                }
              },
            ),
            onPressed: () => controller.switchCamera(),
          ),
        ],
      ),
      body: Stack(
        children: [
          MobileScanner(
            controller: controller,
            onDetect: (capture) {
              if (_hasScanned) return; // Skip if we've already scanned

              final List<Barcode> barcodes = capture.barcodes;
              for (final barcode in barcodes) {
                if (barcode.rawValue != null) {
                  _hasScanned = true; // Set flag before popping
                  print('Popping QR scanner with: ${barcode.rawValue}');
                  Navigator.pop(context, barcode.rawValue);
                  break;
                }
              }
            },
          ),
          // Overlay with a centered scanning area
          Container(
            decoration: ShapeDecoration(
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
                side: const BorderSide(color: Color(0xFF0CE6ED), width: 2),
              ),
            ),
            margin: const EdgeInsets.all(50),
          ),
          // Scanning hint text
          Positioned(
            bottom: 100,
            left: 0,
            right: 0,
            child: Text(
              'Position the QR code within the frame',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Colors.white.useOpacity(0.8),
                fontSize: 16,
                fontFamily: 'Fira Code',
                fontWeight: FontWeight.w400,
              ),
            ),
          ),
        ],
      ),
    );
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/welcome_screen.dart ---
import 'package:flutter/material.dart';
import 'package:video_player/video_player.dart';
import 'package:resonance_network_wallet/features/main/screens/import_wallet_screen.dart';
import 'package:resonance_network_wallet/features/main/screens/create_wallet_and_backup_screen.dart';
import 'package:flutter_svg/flutter_svg.dart';

class WelcomeScreen extends StatefulWidget {
  const WelcomeScreen({super.key});

  @override
  State<WelcomeScreen> createState() => _WelcomeScreenState();
}

class _WelcomeScreenState extends State<WelcomeScreen> {
  late VideoPlayerController _controller;

  @override
  void initState() {
    super.initState();
    // Initialize the controller
    _controller = VideoPlayerController.asset('assets/intro_bg_video.mp4')
      ..initialize().then((_) {
        // Ensure the first frame is shown after the video is initialized
        // and immediately play and loop
        if (!mounted) return; // Check if widget is still mounted
        _controller.play();
        _controller.setLooping(true);
        // Trigger a rebuild once initialized to show the video
        setState(() {});
      }).catchError((error) {
        // Handle initialization error
        debugPrint('Video player initialization error: $error');
      });
  }

  @override
  void dispose() {
    // Ensure disposing of the VideoPlayerController to free up resources.
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF0E0E0E),
      body: Stack(
        children: <Widget>[
          // Video Player Background
          SizedBox.expand(
            child: FittedBox(
              fit: BoxFit.cover,
              child: _controller.value.isInitialized
                  ? SizedBox(
                      width: _controller.value.size.width,
                      height: _controller.value.size.height,
                      child: VideoPlayer(_controller),
                    )
                  : Container(
                      // Placeholder while video loads
                      color: const Color(0xFF0E0E0E),
                      // Optionally, show the static image as placeholder:
                      // child: Image.asset('assets/light_leak_effect_background.jpg', fit: BoxFit.cover),
                    ),
            ),
          ),

          // --- Keep Existing UI Elements ---
          Positioned(
            left: 0,
            right: 0,
            top: MediaQuery.of(context).size.height * 0.15, // Adjust positioning as needed
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const SizedBox(height: 60), // Spacing from Figma
                Center(
                  child: Column(
                    // Wrap in Column to add text below
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      SvgPicture.asset(
                        'assets/quantus_logo.svg', // Changed from res_logo_main.svg
                        height: 130.0, // Adjust height for the icon
                        fit: BoxFit.contain,
                      ),
                      // const SizedBox(height: 15), // Space between icon and text
                      // const Text(
                      //   'QUANTUS',
                      //   style: TextStyle(
                      //     color: Color(0xFFE6E6E6),
                      //     fontSize: 48, // Adjust font size as needed
                      //     fontFamily: 'Fira Code',
                      //     fontWeight: FontWeight.w100, // Match button weight
                      //     letterSpacing: 3.0, // Added letter spacing
                      //   ),
                      // ),
                    ],
                  ),
                ),
                const SizedBox(height: 80),
                const Padding(
                  padding: EdgeInsets.symmetric(horizontal: 24),
                  child: Text(
                    'Quantum safe\n from the ground up',
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Color(0xFFE6E6E6),
                      fontSize: 21,
                      fontFamily: 'Fira Code',
                      fontWeight: FontWeight.w400,
                    ),
                  ),
                ),
                const SizedBox(height: 27), // Spacing from Figma
              ],
            ),
          ),
          Positioned(
            bottom: MediaQuery.of(context).padding.bottom + 60, // Position above bottom safe area
            left: 16,
            right: 16,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      foregroundColor: const Color(0xFF0E0E0E),
                      backgroundColor: const Color(0xFFE6E6E6), // Use const
                      padding: const EdgeInsets.symmetric(vertical: 16), // Use const
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(5.0),
                      ),
                    ),
                    onPressed: () {
                      Navigator.push(
                        context,
                        MaterialPageRoute(builder: (context) => const CreateWalletAndBackupScreen()),
                      );
                    },
                    child: const Text(
                      'Create New Wallet',
                      style: TextStyle(
                        fontSize: 18,
                        fontFamily: 'Fira Code',
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 16), // Use const
                SizedBox(
                  width: double.infinity,
                  child: OutlinedButton(
                    style: OutlinedButton.styleFrom(
                      foregroundColor: const Color(0xFFE6E6E6),
                      side: const BorderSide(color: Color(0xFFE6E6E6)), // Use const
                      padding: const EdgeInsets.symmetric(vertical: 16), // Use const
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(5.0),
                      ),
                    ),
                    onPressed: () {
                      Navigator.push(
                        context,
                        MaterialPageRoute(builder: (context) => const ImportWalletScreen()),
                      );
                    },
                    child: const Text(
                      'Import Existing Wallet',
                      style: TextStyle(
                        fontSize: 18,
                        fontFamily: 'Fira Code',
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/app.dart ---
import 'package:flutter/material.dart';
import 'package:quantus_sdk/quantus_sdk.dart';
import 'package:resonance_network_wallet/features/main/screens/wallet_initializer.dart';
import 'package:resonance_network_wallet/features/main/screens/send_screen.dart';

class ResonanceWalletApp extends StatelessWidget {
  const ResonanceWalletApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Quantus Wallet',
      initialRoute: '/',
      routes: {
        '/': (context) => const WalletInitializer(),
        '/send': (context) => const SendScreen(),
      },
      theme: ThemeData(
        primaryColor: const Color(0xFF6B46C1), // Deep purple
        scaffoldBackgroundColor: const Color(0xFF1A1A1A), // Dark background
        cardColor: const Color(0xFF2D2D2D), // Slightly lighter dark for cards
        colorScheme: ColorScheme.dark(
          primary: const Color(0xFF6B46C1), // Deep purple
          secondary: const Color(0xFF9F7AEA), // Lighter purple
          surface: const Color(0xFF2D2D2D),
          error: Colors.red.shade400,
        ),
        appBarTheme: const AppBarTheme(
          backgroundColor: Color(0xFF2D2D2D),
          elevation: 0,
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: const Color(0xFF6B46C1),
            foregroundColor: Colors.white,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
          ),
        ),
        outlinedButtonTheme: OutlinedButtonThemeData(
          style: OutlinedButton.styleFrom(
            foregroundColor: const Color(0xFF9F7AEA),
            side: const BorderSide(color: Color(0xFF9F7AEA)),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
          ),
        ),
        textButtonTheme: TextButtonThemeData(
          style: TextButton.styleFrom(
            foregroundColor: const Color(0xFF9F7AEA),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Color(0xFF6B46C1)),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide(color: const Color(0xFF6B46C1).useOpacity(0.5)),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Color(0xFF9F7AEA)),
          ),
          filled: true,
          fillColor: const Color(0xFF2D2D2D),
        ),
      ),
      darkTheme: ThemeData(
        primaryColor: const Color(0xFF6B46C1),
        scaffoldBackgroundColor: const Color(0xFF1A1A1A),
        cardColor: const Color(0xFF2D2D2D),
        colorScheme: ColorScheme.dark(
          primary: const Color(0xFF6B46C1),
          secondary: const Color(0xFF9F7AEA),
          surface: const Color(0xFF2D2D2D),
          error: Colors.red.shade400,
        ),
        appBarTheme: const AppBarTheme(
          backgroundColor: Color(0xFF2D2D2D),
          elevation: 0,
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: const Color(0xFF6B46C1),
            foregroundColor: Colors.white,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
          ),
        ),
        outlinedButtonTheme: OutlinedButtonThemeData(
          style: OutlinedButton.styleFrom(
            foregroundColor: const Color(0xFF9F7AEA),
            side: const BorderSide(color: Color(0xFF9F7AEA)),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
          ),
        ),
        textButtonTheme: TextButtonThemeData(
          style: TextButton.styleFrom(
            foregroundColor: const Color(0xFF9F7AEA),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Color(0xFF6B46C1)),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide(color: const Color(0xFF6B46C1).useOpacity(0.5)),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Color(0xFF9F7AEA)),
          ),
          filled: true,
          fillColor: const Color(0xFF2D2D2D),
        ),
      ),
      themeMode: ThemeMode.dark,
    );
  }
}


--- FILE: ./mobile-app/lib/features/main/screens/receive_screen.dart ---
import 'package:flutter/material.dart';
import 'package:qr_flutter/qr_flutter.dart';
import 'package:quantus_sdk/quantus_sdk.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'dart:ui';

class ReceiveSheet extends StatefulWidget {
  const ReceiveSheet({super.key});

  @override
  State<ReceiveSheet> createState() => _ReceiveSheetState();
}

class _ReceiveSheetState extends State<ReceiveSheet> {
  String? _accountId;
  final HumanReadableChecksumService _checksumService = HumanReadableChecksumService();
  final SettingsService _settingsService = SettingsService();

  @override
  void initState() {
    super.initState();
    _checksumService.initialize();
    _loadAccountData();
  }

  Future<void> _loadAccountData() async {
    try {
      final accountId = await _settingsService.getAccountId();

      if (accountId == null) {
        throw Exception('No account found');
      }

      setState(() {
        _accountId = accountId;
      });
    } catch (e) {
      debugPrint('Error loading account data: $e');
      if (mounted) {
        setState(() {});
      }
    }
  }

  void _copyAddress() {
    if (_accountId != null) {
      Clipboard.setData(ClipboardData(text: _accountId!));
      showTopSnackBar(
        context,
        title: 'Copied!',
        message: 'Address copied to clipboard',
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 35, vertical: 16),
        decoration: ShapeDecoration(
          color: Colors.black,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          mainAxisAlignment: MainAxisAlignment.start,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(7),
              decoration: ShapeDecoration(
                color: Colors.black,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(100),
                ),
              ),
              child: const Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  SizedBox(width: 10, height: 10),
                ],
              ),
            ),
            const SizedBox(height: 28),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                SvgPicture.asset(
                  'assets/receive_icon.svg',
                  width: 37,
                  height: 37,
                ),
                const SizedBox(width: 7),
                const Text(
                  'RECEIVE',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 37,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w300,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 28),
            if (_accountId == null)
              const Center(
                child: CircularProgressIndicator(color: Colors.white),
              )
            else ...[
              Container(
                width: 227,
                height: 227,
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: QrImageView(
                  data: _accountId!,
                  version: QrVersions.auto,
                  size: 260.0,
                  padding: EdgeInsets.zero,
                  backgroundColor: Colors.white,
                  eyeStyle: const QrEyeStyle(
                    eyeShape: QrEyeShape.square,
                    color: Colors.black,
                  ),
                  dataModuleStyle: const QrDataModuleStyle(
                    dataModuleShape: QrDataModuleShape.square,
                    color: Colors.black,
                  ),
                ),
              ),
              const SizedBox(height: 28),
              Column(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  FutureBuilder<String?>(
                    future: _checksumService.getHumanReadableName(_accountId!),
                    builder: (context, snapshot) {
                      if (snapshot.connectionState == ConnectionState.waiting) {
                        return const SizedBox(
                            height: 14,
                            child: Row(mainAxisAlignment: MainAxisAlignment.center, children: [
                              SizedBox(
                                  width: 12,
                                  height: 12,
                                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white54)),
                              SizedBox(width: 8),
                              Text('Loading name...', style: TextStyle(color: Colors.white54, fontSize: 12)),
                            ]));
                      } else if (snapshot.hasError ||
                          !snapshot.hasData ||
                          snapshot.data == null ||
                          snapshot.data!.isEmpty) {
                        debugPrint('Error loading checksum name for $_accountId: ${snapshot.error}');
                        return const Text(
                          'Name not found',
                          style: TextStyle(
                            color: Colors.white70,
                            fontSize: 12,
                            fontFamily: 'Fira Code',
                            fontWeight: FontWeight.w500,
                          ),
                          textAlign: TextAlign.center,
                        );
                      } else {
                        return Text(
                          snapshot.data!,
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 12,
                            fontFamily: 'Fira Code',
                            fontWeight: FontWeight.w500,
                          ),
                          textAlign: TextAlign.center,
                        );
                      }
                    },
                  ),
                  const SizedBox(height: 8),
                  Opacity(
                    opacity: 0.5,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          '${_accountId!.substring(0, 6)}...${_accountId!.substring(_accountId!.length - 5)}',
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 12,
                            fontFamily: 'Fira Code',
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                        const SizedBox(width: 8),
                        InkWell(
                          onTap: _copyAddress,
                          child: SvgPicture.asset(
                            'assets/copy_icon.svg',
                            width: 16,
                            height: 16,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 28),
              SizedBox(
                width: 305,
                height: 44,
                child: ElevatedButton(
                  onPressed: _copyAddress,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.white,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(5),
                    ),
                  ),
                  child: const Text(
                    'Share',
                    style: TextStyle(
                      color: Color(0xFF0E0E0E),
                      fontSize: 18,
                      fontFamily: 'Fira Code',
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

// Helper function to show the receive sheet
void showReceiveSheet(BuildContext context) {
  showModalBottomSheet(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    builder: (context) => BackdropFilter(
      filter: ImageFilter.blur(sigmaX: 3, sigmaY: 3),
      child: Container(
        color: Colors.black.useOpacity(0.2),
        child: const ReceiveSheet(),
      ),
    ),
  );
}


--- FILE: ./mobile-app/lib/shared/themes/app_theme.dart ---
import 'package:flutter/material.dart';
import 'package:quantus_sdk/quantus_sdk.dart';

class AppTheme {
  static const Color primaryColor = Color(0xFF6B46C1);
  static const Color secondaryColor = Color(0xFF9F7AEA);
  static const Color backgroundColor = Color(0xFF1A1A1A);
  static const Color cardColor = Color(0xFF2D2D2D);
  static const Color errorColor = Colors.red;

  static ThemeData get darkTheme {
    return ThemeData(
      primaryColor: primaryColor,
      scaffoldBackgroundColor: backgroundColor,
      cardColor: cardColor,
      colorScheme: const ColorScheme.dark(
        primary: primaryColor,
        secondary: secondaryColor,
        surface: cardColor,
        error: errorColor,
      ),
      appBarTheme: const AppBarTheme(
        backgroundColor: cardColor,
        elevation: 0,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: primaryColor,
          foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: secondaryColor,
          side: const BorderSide(color: secondaryColor),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: secondaryColor,
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: primaryColor),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: primaryColor.useOpacity(0.5)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: secondaryColor),
        ),
        filled: true,
        fillColor: cardColor,
      ),
    );
  }
}


--- FILE: ./mobile-app/lib/shared/routes/app_routes.dart ---
class AppRoutes {
  static const String welcome = '/';
  static const String createWallet = '/create-wallet';
  static const String importWallet = '/import-wallet';
  static const String walletMain = '/wallet-main';
  static const String send = '/send';
  static const String accountProfile = '/account-profile';
}


--- FILE: ./mobile-app/lib/main.dart ---
import 'package:flutter/material.dart';
import 'package:resonance_network_wallet/features/main/screens/app.dart';
import 'package:quantus_sdk/quantus_sdk.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await SubstrateService().initialize();
  await RustLib.init();
  runApp(const ResonanceWalletApp());
}


--- FILE: ./quantus_sdk/lib/core/widgets/top_snackbar_content.dart ---
import 'package:flutter/material.dart';
import 'package:quantus_sdk/src/core/extensions/color_extensions.dart';

class TopSnackBarContent extends StatelessWidget {
  final String title;
  final String message;
  final Widget? icon;

  const TopSnackBarContent({
    super.key,
    required this.title,
    required this.message,
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    // Default Icon if none provided
    final Widget displayIcon = icon ??
        Container(
          width: 36,
          height: 36,
          decoration: const ShapeDecoration(
            color: Color(0xFF494949), // Default grey background
            shape: OvalBorder(), // Use OvalBorder for circle
          ),
          alignment: Alignment.center,
          child: const Icon(Icons.check, color: Colors.white, size: 20), // Default check icon
        );

    return Container(
      // width: 343, // Width will be handled by the flash package's constraints
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: ShapeDecoration(
          color: Colors.white, // White background
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
          // Optional shadow for better visibility
          shadows: const [
            BoxShadow(
              color: Colors.black26,
              blurRadius: 4,
              offset: Offset(0, 2),
            )
          ]),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          displayIcon, // Use the provided or default icon
          const SizedBox(width: 16), // Spacing
          Expanded(
            // Allow text to wrap
            child: Column(
              mainAxisSize: MainAxisSize.min,
              mainAxisAlignment: MainAxisAlignment.start,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: const TextStyle(
                    color: Colors.black,
                    fontSize: 14,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w500, // Slightly bolder title
                  ),
                ),
                const SizedBox(height: 2), // Spacing
                Text(
                  message,
                  style: TextStyle(
                    color: Colors.black.useOpacity(153 / 255.0), // Black with alpha
                    fontSize: 12,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w400, // Regular weight for message
                  ),
                  // softWrap: true, // Ensure message wraps
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}


--- FILE: ./quantus_sdk/lib/quantus_sdk.dart ---
library;

export 'src/core/services/substrate_service.dart';
export 'src/rust/frb_generated.dart';
export 'src/core/extensions/color_extensions.dart';
export 'src/core/services/settings_service.dart';
export 'src/core/constants/app_constants.dart';
export 'src/core/services/human_readable_checksum_service.dart';
export 'src/core/services/number_formatting_service.dart';
export 'src/core/models/transaction_model.dart';
export 'src/core/helpers/snackbar_helper.dart';
export 'src/core/services/chain_history_service.dart';
export 'src/core/widgets/top_snackbar_content.dart';
export 'src/core/widgets/gradient_action_button.dart';
// note we have to hide some things here because they're exported by substrate service
// should probably expise all of crypto.dart through substrateservice instead TODO...
export 'src/rust/api/crypto.dart' hide crystalAlice, crystalCharlie, crystalBob;


--- FILE: ./quantus_sdk/lib/src/core/constants/app_constants.dart ---
class AppConstants {
  static const String appName = 'Quantus Wallet';
  static const String tokenSymbol = 'QUAN';

  // static const String rpcEndpoint = 'ws://127.0.0.1:9944'; // local testing
  static const String rpcEndpoint = 'wss://a.t.res.fm:443';

  static const String graphQlEndpoint = 'https://gql.res.fm/graphql';

  // Development accounts
  static const String crystalAlice = '//Crystal Alice';
  static const String crystalBob = '//Crystal Bob';
  static const String crystalCharlie = '//Crystal Charlie';

  // Shared Preferences keys
  static const String hasWalletKey = 'has_wallet';
  static const String mnemonicKey = 'mnemonic';
  static const String accountIdKey = 'account_id';
}


--- FILE: ./quantus_sdk/lib/src/core/models/transaction_status.dart ---
enum TransactionStatus {
  pending,
  confirmed,
  failed,
}


--- FILE: ./quantus_sdk/lib/src/core/models/transaction_type.dart ---
enum TransactionType {
  sent,
  received,
}


--- FILE: ./quantus_sdk/lib/src/core/models/transaction_model.dart ---
import 'transaction_status.dart';
import 'transaction_type.dart';

class Transaction {
  final String id;
  final BigInt amount;
  final DateTime timestamp;
  final TransactionType type;
  final String otherParty;
  final TransactionStatus status;

  Transaction({
    required this.id,
    required this.amount,
    required this.timestamp,
    required this.type,
    required this.otherParty,
    required this.status,
  });
}


--- FILE: ./quantus_sdk/lib/src/core/extensions/color_extensions.dart ---
import 'dart:ui';

extension ColorOpacityExtension on Color {
  /// Returns a new color that is a blend of this color and the given [opacity].
  ///
  /// The [opacity] argument must be between 0.0 and 1.0 (inclusive).
  /// An opacity of 1.0 is fully opaque, and 0.0 is fully transparent.
  Color useOpacity(double opacity) {
    // this is the same code from the deprecated useOpacity method... nothing wrong with it.
    assert(opacity >= 0.0 && opacity <= 1.0);
    return withAlpha((255.0 * opacity).round());
  }
}


--- FILE: ./quantus_sdk/lib/src/core/helpers/snackbar_helper.dart ---
import 'package:flash/flash.dart';
import 'package:flash/flash_helper.dart';
import 'package:flutter/material.dart';
import '../widgets/top_snackbar_content.dart'; // Import the content widget

// Helper function to show a custom top snackbar
Future<void> showTopSnackBar(
  BuildContext context, {
  required String title,
  required String message,
  Widget? icon,
  Duration duration = const Duration(seconds: 3), // Default duration
  FlashBehavior style = FlashBehavior.floating, // Floating style
}) async {
  // Use context.showFlash<T> for better type safety and context awareness if available,
  // otherwise fallback to showFlash<T>
  await context.showFlash<void>(
    duration: duration,
    persistent: true,
    builder: (context, controller) {
      return FlashBar(
        controller: controller,
        behavior: style,
        backgroundColor: Colors.transparent, // FlashBar itself is transparent
        surfaceTintColor: Colors.transparent,
        shadowColor: Colors.transparent,
        indicatorColor: Colors.transparent,
        position: FlashPosition.top, // Position at the top
        clipBehavior: Clip.none, // Allow shadow to be visible if added
        shouldIconPulse: false,
        // Pass the actual content widget
        content: TopSnackBarContent(
          title: title,
          message: message,
          icon: icon, // Pass the icon through
        ),
      );
    },
  );
}

// Example of how to create a specific error icon if needed elsewhere
Widget buildErrorIcon() {
  return Container(
    width: 36,
    height: 36,
    decoration: const ShapeDecoration(
      color: Colors.redAccent, // Red background for error
      shape: OvalBorder(),
    ),
    alignment: Alignment.center,
    child: const Icon(Icons.error_outline, color: Colors.white, size: 20),
  );
}


--- FILE: ./quantus_sdk/lib/src/core/services/number_formatting_service.dart ---
// Keep for potential future use (grouping)
import 'package:decimal/decimal.dart';
import 'package:flutter/foundation.dart'; // For debugPrint

class NumberFormattingService {
  static const int decimals = 12;
  static final BigInt scaleFactorBigInt = BigInt.from(10).pow(decimals);
  static final Decimal scaleFactorDecimal = Decimal.fromBigInt(scaleFactorBigInt);

  /// Formats a raw BigInt balance (representing the smallest unit) into a
  /// user-readable string with a specified number of decimal places.
  ///
  /// Example: 1234500000000 -> "1.2345" (with maxDecimals = 4)
  String formatBalance(BigInt balance, {int maxDecimals = 4}) {
    if (balance == BigInt.zero) {
      return '0';
    }

    // Perform division with Decimal
    final rationalBalance = Decimal.fromBigInt(balance) / scaleFactorDecimal;

    // Convert Rational to Decimal *without* premature scaling
    final decimalBalance = rationalBalance.toDecimal();

    // Now use toStringAsFixed on the resulting Decimal
    String formatted = decimalBalance.toStringAsFixed(maxDecimals);

    // Simple manual trim of trailing zeros and decimal point if necessary
    if (formatted.contains('.')) {
      formatted = formatted.replaceAll(RegExp(r'0+$'), ''); // Remove trailing zeros
      if (formatted.endsWith('.')) {
        formatted = formatted.substring(0, formatted.length - 1); // Remove trailing decimal point
      }
    }

    // Optional: Add grouping separators for the integer part if needed in the future
    // using NumberFormat on the integer part before combining.

    return formatted;
  }

  /// Parses a user-entered formatted string amount (e.g., "1.23") into a
  /// raw BigInt amount scaled by the chain's decimals.
  ///
  /// Returns null if the input string is invalid.
  BigInt? parseAmount(String formattedAmount) {
    if (formattedAmount.isEmpty) {
      return BigInt.zero;
    }

    try {
      final decimalAmount = Decimal.parse(formattedAmount);
      // Check if input precision exceeds chain precision
      if (decimalAmount.scale > decimals) {
        // Option 1: Truncate (like toBigInt does)
        // Option 2: Throw an error - let's stick with truncation for now
        debugPrint('Warning: Input amount $formattedAmount exceeds $decimals decimals, will be truncated.');
      }
      final rawDecimalAmount = decimalAmount * scaleFactorDecimal;
      return rawDecimalAmount.toBigInt(); // toBigInt truncates
    } catch (e) {
      // Correct debugPrint usage
      debugPrint('Error parsing amount $formattedAmount: $e');
      return null;
    }
  }
}


--- FILE: ./quantus_sdk/lib/src/core/services/substrate_service.dart ---
import 'package:flutter/foundation.dart';
import 'package:polkadart/polkadart.dart';
import 'package:polkadart_keyring/polkadart_keyring.dart';
import '../constants/app_constants.dart';
import 'number_formatting_service.dart';
import 'dart:math';
import 'package:bip39_mnemonic/bip39_mnemonic.dart';
import 'dart:async';
import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'dart:io';

import 'package:quantus_sdk/generated/resonance/resonance.dart';
import 'package:quantus_sdk/generated/resonance/types/sp_runtime/multiaddress/multi_address.dart' as multi_address;
import 'package:ss58/ss58.dart';
import 'package:quantus_sdk/src/rust/api/crypto.dart' as crypto;
import 'package:quantus_sdk/src/resonance_extrinsic_payload.dart';
import 'settings_service.dart';

enum ConnectionStatus { connecting, connected, disconnected, error }

class DilithiumWalletInfo {
  final crypto.Keypair keypair;
  final String accountId;
  final String? mnemonic;
  final String walletName;
  DilithiumWalletInfo({
    required this.keypair,
    required this.accountId,
    this.mnemonic,
    required this.walletName,
  });

  factory DilithiumWalletInfo.fromKeyPair(crypto.Keypair keypair, {required String walletName, String? mnemonic}) {
    return DilithiumWalletInfo(
      keypair: keypair,
      accountId: keypair.ss58Address,
      mnemonic: mnemonic,
      walletName: walletName,
    );
  }
}

const crystalAlice = '//Crystal Alice';
const crystalBob = '//Crystal Bob';
const crystalCharlie = '//Crystal Charlie';

extension on Address {
  // making an alias here because pubkey is not a public key it's just the raw decoded address - decoding from ss58 to a bytes array
  Uint8List get addressByes => pubkey;
}

// Dilithium Keypair
// This differs from the built in keypairs in that the public key is very long.
// The address is a poseidon hash of the public key.
// We get the address as ss58 from our library, and we can convert it back into bytes if needed.
extension on crypto.Keypair {
  String get ss58Address => crypto.toAccountId(obj: this);
  Uint8List get addressBytes => Address.decode(ss58Address).addressByes;
}

class SubstrateService {
  static final SubstrateService _instance = SubstrateService._internal();
  factory SubstrateService() => _instance;
  SubstrateService._internal();

  Provider? _provider;
  StateApi? _stateApi;
  AuthorApi? _authorApi;
  static const String _rpcEndpoint = AppConstants.rpcEndpoint;
  final SettingsService _settingsService = SettingsService();

  // Add StreamController for connection status
  final _connectionStatusController = StreamController<ConnectionStatus>.broadcast();

  // Expose the stream
  Stream<ConnectionStatus> get connectionStatus => _connectionStatusController.stream;

  Future<void> initialize() async {
    // Only create the provider if it hasn't been created yet
    // If it exists, assume it's already connected or will attempt to reconnect automatically.
    if (_provider == null) {
      _provider = Provider.fromUri(Uri.parse(_rpcEndpoint));
      // Initialize APIs with the new provider
      _stateApi = StateApi(_provider!);
      _authorApi = AuthorApi(_provider!);
    }

    // Attempt to connect
    try {
      _connectionStatusController.add(ConnectionStatus.connecting);
      // Only attempt to connect if provider was just created or is not currently connecting/connected
      // A simple check for null provider implies it needs connecting
      if (_provider != null) {
        await _provider!.connect().timeout(const Duration(seconds: 15));
        _connectionStatusController.add(ConnectionStatus.connected);
      }
    } catch (e) {
      _connectionStatusController.add(ConnectionStatus.error);
      print('Initial connection failed: $e');
      // Optionally rethrow or handle based on app's startup requirements
    }
  }

  Future<void> reconnect() async {
    print('Attempting to recreate and reconnect Substrate provider...');
    const Duration networkTimeout = Duration(seconds: 15);

    // Dispose of the old provider instance if it exists
    // Note: Polkadart Provider might not have a public dispose/close.
    // Relying on garbage collection or checking Polkadart docs for proper cleanup.
    // To force re-initialization with a potentially new connection,
    // we'll create a new Provider instance.
    _provider = Provider.fromUri(Uri.parse(_rpcEndpoint));

    // Re-initialize APIs with the new provider
    _stateApi = StateApi(_provider!);
    _authorApi = AuthorApi(_provider!);

    // Attempt to connect the new provider with timeout
    try {
      _connectionStatusController.add(ConnectionStatus.connecting);
      await _provider!.connect().timeout(networkTimeout);
      _connectionStatusController.add(ConnectionStatus.connected);
      print('New provider connected successfully during reconnect.');
    } catch (e) {
      _connectionStatusController.add(ConnectionStatus.disconnected); // Or error
      print('Failed to recreate/reconnect provider: $e');
      if (e is TimeoutException) {
        throw Exception('Failed to reconnect to the network: Connection timed out.');
      } else {
        throw Exception('Failed to reconnect to the network: $e');
      }
    }
  }

  Future<BigInt> getFee(String senderAddress, String recipientAddress, BigInt amount) async {
    try {
      final resonanceApi = Resonance(_provider!);
      final multiDest = const multi_address.$MultiAddress().id(Address.decode(recipientAddress).pubkey);

      // Retrieve sender's mnemonic and generate keypair
      // Assuming senderAddress corresponds to the current wallet's account ID
      crypto.Keypair senderWallet = await _getUserWallet();

      // Get necessary info for the transaction (similar to balanceTransfer)
      final runtimeVersion = await _stateApi!.getRuntimeVersion();
      final specVersion = runtimeVersion.specVersion;
      final transactionVersion = runtimeVersion.transactionVersion;

      final block = await _provider!.send('chain_getBlock', []);
      final blockNumber = int.parse(block.result['block']['header']['number']);

      final blockHash = (await _provider!.send('chain_getBlockHash', [])).result.replaceAll('0x', '');
      final genesisHash = (await _provider!.send('chain_getBlockHash', [0])).result.replaceAll('0x', '');

      // Get the next nonce for the sender
      final nonceResult = await _provider!.send('system_accountNextIndex', [senderWallet.ss58Address]);
      final nonce = int.parse(nonceResult.result.toString());

      // Create the call for fee estimation
      final runtimeCall = resonanceApi.tx.balances.transferKeepAlive(dest: multiDest, value: amount);
      final transferCall = runtimeCall.encode();

      // Create and sign a dummy payload for fee estimation
      final payloadToSign = SigningPayload(
        method: transferCall,
        specVersion: specVersion,
        transactionVersion: transactionVersion,
        genesisHash: genesisHash,
        blockHash: blockHash,
        blockNumber: blockNumber,
        eraPeriod: 64, // Use a reasonable era period
        nonce: nonce,
        tip: 0, // Assuming no tip for fee estimation
      );

      final payload = payloadToSign.encode(resonanceApi.registry);
      final signature = crypto.signMessage(keypair: senderWallet, message: payload);

      // Construct the signed extrinsic payload (Resonance specific)
      final signatureWithPublicKeyBytes = _combineSignatureAndPubkey(signature, senderWallet.publicKey); // Reuse helper

      final signedExtrinsic = ResonanceExtrinsicPayload(
        signer: Uint8List.fromList(senderWallet.addressBytes), // Use signer address bytes
        method: transferCall, // The encoded call method
        signature: signatureWithPublicKeyBytes, // The signature
        eraPeriod: 64, // Must match SigningPayload
        blockNumber: blockNumber, // Must match SigningPayload
        nonce: nonce, // Must match SigningPayload
        tip: 0, // Must match SigningPayload
      ).encodeResonance(resonanceApi.registry, ResonanceSignatureType.resonance);

      // Convert encoded signed extrinsic to hex string
      final hexEncodedSignedExtrinsic = bytesToHex(signedExtrinsic);

      // Use provider.send to call the payment_queryInfo RPC with the signed extrinsic
      final result =
          await _provider!.send('payment_queryInfo', [hexEncodedSignedExtrinsic, null]); // null for block hash

      // Parse the result to get the partialFee
      // The result structure is typically {'partialFee': '...'} for this RPC
      final partialFeeString = result.result['partialFee'] as String;
      final partialFee = BigInt.parse(partialFeeString);

      print('partialFee: $partialFee');

      return partialFee;
    } catch (e) {
      // If a network error occurs here, update the connection status
      if (e.toString().contains('WebSocketChannelException') || e is SocketException || e is TimeoutException) {
        _connectionStatusController.add(ConnectionStatus.disconnected);
      }
      print('Error estimating fee: $e');
      throw Exception('Failed to estimate network fee: $e');
    }
  }

  Future<crypto.Keypair> _getUserWallet() async {
    final settingsService = SettingsService();
    final senderSeed = await settingsService.getMnemonic();
    if (senderSeed == null || senderSeed.isEmpty) {
      throw Exception('Sender mnemonic not found for fee estimation.');
    }
    crypto.Keypair senderWallet = dilithiumKeypairFromMnemonic(senderSeed);
    return senderWallet;
  }

  Future<DilithiumWalletInfo> generateWalletFromSeed(String seedPhrase) async {
    try {
      crypto.Keypair keypair = dilithiumKeypairFromMnemonic(seedPhrase);
      // final name = await HumanReadableChecksumService().getHumanReadableName(keypair.ss58Address);
      return DilithiumWalletInfo.fromKeyPair(keypair, walletName: '');
    } catch (e) {
      throw Exception('Failed to generate wallet: $e');
    }
  }

  Future<BigInt> queryBalance(String address) async {
    try {
      // Create Resonance API instance
      final resonanceApi = Resonance(_provider!);
      // Account from SS58 address
      final account = Address.decode(address);

      // Retrieve Account Balance
      final accountInfo = await resonanceApi.query.system.account(account.pubkey);

      // Get the free balance
      return accountInfo.data.free;
    } catch (e) {
      // If a network error occurs here, update the connection status
      if (e.toString().contains('WebSocketChannelException') || e is SocketException || e is TimeoutException) {
        _connectionStatusController.add(ConnectionStatus.disconnected);
      }
      print('Error querying balance: $e');
      throw Exception('Failed to query balance: $e');
    }
  }

  Uint8List _combineSignatureAndPubkey(List<int> signature, List<int> pubkey) {
    final result = Uint8List(signature.length + pubkey.length);
    result.setAll(0, signature);
    result.setAll(signature.length, pubkey);

    // Calculate and print signature checksum
    final signatureHash = sha256.convert(signature).bytes;
    final signatureChecksum = base64.encode(signatureHash).substring(0, 8);
    print('Signature checksum: $signatureChecksum');

    return result;
  }

  Future<void> _printBalance(String prefix, String address) async {
    final balance = await queryBalance(address);
    print('$prefix Balance for $address: ${balance.toString()}');
  }

  crypto.Keypair dilithiumKeypairFromMnemonic(String senderSeed) {
    crypto.Keypair senderWallet;
    if (senderSeed.startsWith('//')) {
      switch (senderSeed) {
        case crystalAlice:
          senderWallet = crypto.crystalAlice();
          break;
        case crystalBob:
          senderWallet = crypto.crystalBob();
          break;
        case crystalCharlie:
          senderWallet = crypto.crystalCharlie();
          break;
        default:
          throw Exception('Invalid sender seed: $senderSeed');
      }
    } else {
      // Get the sender's wallet
      senderWallet = crypto.generateKeypair(mnemonicStr: senderSeed);
    }
    return senderWallet;
  }

  Future<String> balanceTransfer(String senderSeed, String targetAddress, BigInt amount) async {
    try {
      // Ensure provider is connected before proceeding
      if (_provider == null) {
        await initialize();
      }

      // Get the sender's wallet
      print('sending to $targetAddress');
      print('amount (BigInt): $amount');
      print('amount (${AppConstants.tokenSymbol} formatted): ${NumberFormattingService().formatBalance(amount)}');

      crypto.Keypair senderWallet = dilithiumKeypairFromMnemonic(senderSeed);

      await _printBalance('Sender before ', senderWallet.ss58Address);
      await _printBalance('Target before ', targetAddress);

      // Get all necessary info for the transaction in one go to minimize timing issues
      final runtimeVersion = await _stateApi!.getRuntimeVersion();
      final specVersion = runtimeVersion.specVersion;
      final transactionVersion = runtimeVersion.transactionVersion;

      final block = await _provider!.send('chain_getBlock', []);
      final blockNumber = int.parse(block.result['block']['header']['number']);
      final blockHash = (await _provider!.send('chain_getBlockHash', [])).result.replaceAll('0x', '');
      final genesisHash = (await _provider!.send('chain_getBlockHash', [0])).result.replaceAll('0x', '');
      final nonceResult = await _provider!.send('system_accountNextIndex', [senderWallet.ss58Address]);
      final nonce = int.parse(nonceResult.result.toString());

      // Use the passed BigInt amount directly
      final BigInt rawAmount = amount;

      final dest = targetAddress;
      final multiDest = const multi_address.$MultiAddress().id(Address.decode(dest).pubkey);
      print('Destination: $dest');

      // Encode call
      final resonanceApi = Resonance(_provider!);
      final runtimeCall = resonanceApi.tx.balances.transferKeepAlive(dest: multiDest, value: rawAmount);
      final transferCall = runtimeCall.encode();

      // Create and sign the payload
      final payloadToSign = SigningPayload(
        method: transferCall,
        specVersion: specVersion,
        transactionVersion: transactionVersion,
        genesisHash: genesisHash,
        blockHash: blockHash,
        blockNumber: blockNumber,
        eraPeriod: 64,
        nonce: nonce,
        tip: 0,
      );

      final payload = payloadToSign.encode(resonanceApi.registry);
      final signature = crypto.signMessage(keypair: senderWallet, message: payload);
      final signatureWithPublicKeyBytes = _combineSignatureAndPubkey(signature, senderWallet.publicKey);

      // Create the extrinsic
      var extrinsic = ResonanceExtrinsicPayload(
        signer: Uint8List.fromList(senderWallet.addressBytes),
        method: transferCall,
        signature: signatureWithPublicKeyBytes,
        eraPeriod: 64,
        blockNumber: blockNumber,
        nonce: nonce,
        tip: 0,
      ).encodeResonance(resonanceApi.registry, ResonanceSignatureType.resonance);

      // Add retry logic for submission
      int retryCount = 0;
      const maxRetries = 3;

      while (retryCount < maxRetries) {
        try {
          await _authorApi!.submitAndWatchExtrinsic(extrinsic, (data) async {
            print('type: ${data.type}, value: ${data.value}');
            await _printBalance('after ', senderWallet.ss58Address);
            await _printBalance('after ', targetAddress);
          });
          return '0';
        } catch (e) {
          retryCount++;
          if (retryCount >= maxRetries) rethrow;
          // Wait a bit before retrying
          await Future.delayed(Duration(milliseconds: 500 * retryCount));
          // Refresh block info for retry
          final newBlock = await _provider!.send('chain_getBlock', []);
          final newBlockNumber = int.parse(newBlock.result['block']['header']['number']);
          final newBlockHash = (await _provider!.send('chain_getBlockHash', [])).result.replaceAll('0x', '');
          final newNonceResult = await _provider!.send('system_accountNextIndex', [senderWallet.ss58Address]);
          final newNonce = int.parse(newNonceResult.result.toString());

          // Recreate payload with new block info
          final newPayloadToSign = SigningPayload(
            method: transferCall,
            specVersion: specVersion,
            transactionVersion: transactionVersion,
            genesisHash: genesisHash,
            blockHash: newBlockHash,
            blockNumber: newBlockNumber,
            eraPeriod: 64,
            nonce: newNonce,
            tip: 0,
          );

          final newPayload = newPayloadToSign.encode(resonanceApi.registry);
          final newSignature = crypto.signMessage(keypair: senderWallet, message: newPayload);
          final newSignatureWithPublicKeyBytes = _combineSignatureAndPubkey(newSignature, senderWallet.publicKey);

          extrinsic = ResonanceExtrinsicPayload(
            signer: Uint8List.fromList(senderWallet.addressBytes),
            method: transferCall,
            signature: newSignatureWithPublicKeyBytes,
            eraPeriod: 64,
            blockNumber: newBlockNumber,
            nonce: newNonce,
            tip: 0,
          ).encodeResonance(resonanceApi.registry, ResonanceSignatureType.resonance);
        }
      }

      return '0';
    } catch (e, stackTrace) {
      print('Failed to transfer balance: $e');
      print('Failed to transfer balance: $stackTrace');
      throw Exception('Failed to transfer balance: $e');
    }
  }

  // reference implementation - this works with sr25519 schnorr signatures
  Future<String> balanceTransferSr25519Deprecated(String senderSeed, String targetAddress, double amount) async {
    try {
      // Get the sender's wallet
      final senderWallet = await KeyPair.sr25519.fromMnemonic(senderSeed);

      print('sender\' wallet: ${senderWallet.address}');

      // Get necessary info for the transaction
      final runtimeVersion = await _stateApi!.getRuntimeVersion();
      final specVersion = runtimeVersion.specVersion;
      final transactionVersion = runtimeVersion.transactionVersion;

      final block = await _provider!.send('chain_getBlock', []);
      final blockNumber = int.parse(block.result['block']['header']['number']);

      final blockHash = (await _provider!.send('chain_getBlockHash', [])).result.replaceAll('0x', '');
      final genesisHash = (await _provider!.send('chain_getBlockHash', [0])).result.replaceAll('0x', '');

      // Get the next nonce for the `sender`
      final nonceResult = await _provider!.send('system_accountNextIndex', [senderWallet.address]);
      final nonce = int.parse(nonceResult.result.toString());

      // Convert amount to chain format (considering decimals)
      final rawAmount = BigInt.from(amount * BigInt.from(10).pow(12).toInt());

      final dest = targetAddress;
      final multiDest = const multi_address.$MultiAddress().id(Address.decode(dest).pubkey);
      print('Destination: $dest');

      // Encode call
      final resonanceApi = Resonance(_provider!);
      final runtimeCall = resonanceApi.tx.balances.transferKeepAlive(dest: multiDest, value: rawAmount);
      final transferCall = runtimeCall.encode();

      // Get metadata for encoding
      // final metadata = await _stateApi.getMetadata();

      // Create and sign the payload
      final payloadToSign = SigningPayload(
        method: transferCall,
        specVersion: specVersion,
        transactionVersion: transactionVersion,
        genesisHash: genesisHash,
        blockHash: blockHash,
        blockNumber: blockNumber,
        eraPeriod: 64,
        nonce: nonce,
        tip: 0,
      );

      final payload = payloadToSign.encode(resonanceApi.registry);

      final signature = senderWallet.sign(payload);

      // Create the extrinsic
      final extrinsic = ExtrinsicPayload(
        signer: Uint8List.fromList(senderWallet.publicKey.bytes),
        method: transferCall,
        signature: signature,
        eraPeriod: 64,
        blockNumber: blockNumber,
        nonce: nonce,
        tip: 0,
      ).encode(resonanceApi.registry, SignatureType.sr25519);

      // Submit the extrinsic

      await _authorApi!.submitAndWatchExtrinsic(extrinsic, (data) {
        print('type: ${data.type}, value: ${data.value}');
      });
      return '0';

      // final hash = await _authorApi.submitExtrinsic(extrinsic);
      // return convert.hex.encode(0);
    } catch (e, stackTrace) {
      print('Failed to transfer balance: $e');
      print('Failed to transfer balance: $stackTrace');
      throw Exception('Failed to transfer balance: $e');
    }
  }

  Future<void> logout() async {
    await _settingsService.clearAll();
  }

  Future<String> generateMnemonic() async {
    try {
      // Generate a random entropy
      final entropy = List<int>.generate(32, (i) => Random.secure().nextInt(256));
      // Generate mnemonic from entropy
      final mnemonic = Mnemonic(entropy, Language.english);

      return mnemonic.sentence;
    } catch (e) {
      throw Exception('Failed to generate mnemonic: $e');
    }
  }

  bool isValidSS58Address(String address) {
    try {
      Address.decode(address);
      return true;
    } catch (e) {
      return false;
    }
  }

  // Helper function to convert bytes to hex string
  String bytesToHex(Uint8List bytes) {
    return bytes.map((byte) => byte.toRadixString(16).padLeft(2, '0')).join();
  }

  void dispose() {
    _connectionStatusController.close();
    // Dispose of the provider instance if it has a dispose/close method
    // _provider.close(); // If a close method exists
  }
}


--- FILE: ./quantus_sdk/lib/src/core/services/settings_service.dart ---
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class SettingsService {
  static final SettingsService _instance = SettingsService._internal();
  factory SettingsService() => _instance;
  SettingsService._internal();

  late SharedPreferences _prefs;
  final _secureStorage = const FlutterSecureStorage();
  bool _initialized = false;

  Future<void> initialize() async {
    if (!_initialized) {
      _prefs = await SharedPreferences.getInstance();
      _initialized = true;
    }
  }

  // Account Settings
  Future<void> setAccountId(String accountId) async {
    await _ensureInitialized();
    await _prefs.setString('account_id', accountId);
  }

  Future<String?> getAccountId() async {
    await _ensureInitialized();
    return _prefs.getString('account_id');
  }

  Future<void> clearAccountId() async {
    await _ensureInitialized();
    await _prefs.remove('account_id');
  }

  // Wallet Name Settings
  Future<void> setWalletName(String name) async {
    await _ensureInitialized();
    await _prefs.setString('wallet_name', name);
  }

  Future<String?> getWalletName() async {
    await _ensureInitialized();
    return _prefs.getString('wallet_name');
  }

  // Wallet Existence
  Future<void> setHasWallet(bool hasWallet) async {
    await _ensureInitialized();
    await _prefs.setBool('has_wallet', hasWallet);
  }

  Future<bool> getHasWallet() async {
    await _ensureInitialized();
    return _prefs.getBool('has_wallet') ?? false;
  }

  // Mnemonic Settings - Using secure storage
  Future<void> setMnemonic(String mnemonic) async {
    await _ensureInitialized();
    await _secureStorage.write(key: 'mnemonic', value: mnemonic);
  }

  Future<String?> getMnemonic() async {
    await _ensureInitialized();

    // TODO remove this at launch
    if (_prefs.getString('mnemonic') != null) {
      debugPrint('mnemonic found in prefs - transferring to secure storage');
      final m = _prefs.getString('mnemonic')!;
      await setMnemonic(m);
      await _prefs.remove('mnemonic');
      return m;
    }

    return await _secureStorage.read(key: 'mnemonic');
  }

  Future<void> clearMnemonic() async {
    await _ensureInitialized();
    await _secureStorage.delete(key: 'mnemonic');
  }

  // Clear all settings
  Future<void> clearAll() async {
    await _ensureInitialized();
    await _prefs.clear();
    await _secureStorage.deleteAll();
  }

  // Helper method to ensure initialization
  Future<void> _ensureInitialized() async {
    if (!_initialized) {
      await initialize();
    }
  }
}


--- FILE: ./quantus_sdk/lib/src/core/services/human_readable_checksum_service.dart ---
import 'dart:async';
import 'dart:isolate';
import 'package:flutter/services.dart';
import 'package:flutter/foundation.dart';
import 'package:human_checksum/human_checksum.dart';

class HumanReadableChecksumService {
  static final HumanReadableChecksumService _instance = HumanReadableChecksumService._internal();
  factory HumanReadableChecksumService() => _instance;
  HumanReadableChecksumService._internal();

  List<String>? _cachedWordList;
  Isolate? _isolate;
  SendPort? _isolateSendPort;
  final _checkPhraseCache = <String, String>{};
  Completer<void>? _isolateReadyCompleter;

  Future<void> initialize() async {
    if (_cachedWordList != null && _isolateSendPort != null && (_isolateReadyCompleter?.isCompleted ?? false)) {
      return;
    }

    if (_isolateReadyCompleter != null && !_isolateReadyCompleter!.isCompleted) {
      await _isolateReadyCompleter!.future;
      return;
    }

    _isolateReadyCompleter = Completer<void>();

    try {
      if (_cachedWordList == null) {
        final wordList = await rootBundle.loadString('assets/text/crypto_checksum_bip39.txt');
        _cachedWordList = wordList.split('\n').where((word) => word.isNotEmpty).toList();

        if (_cachedWordList!.length != 2048) {
          _isolateReadyCompleter!.completeError(Exception('Word list must contain exactly 2048 words'));
          throw Exception('Word list must contain exactly 2048 words');
        }
      }

      if (_isolateSendPort == null) {
        final receivePort = ReceivePort();
        _isolate = await Isolate.spawn(_isolateEntry, [receivePort.sendPort, _cachedWordList!]);
        _isolateSendPort = await receivePort.first as SendPort;
      }

      _isolateReadyCompleter!.complete();
    } catch (e, s) {
      debugPrint('Error during checksum isolate initialization: $e');
      debugPrint('Initialization error stack: $s');
      if (!(_isolateReadyCompleter?.isCompleted ?? false)) {
        _isolateReadyCompleter!.completeError(e);
      }
      _isolate?.kill();
      _isolate = null;
      _isolateSendPort = null;
      _cachedWordList = null;
      rethrow;
    }
  }

  Future<String> getHumanReadableName(String address) async {
    try {
      if (_checkPhraseCache.containsKey(address)) {
        return _checkPhraseCache[address]!;
      }

      if (!(_isolateReadyCompleter?.isCompleted ?? false)) {
        await initialize();
      }

      if (_isolateSendPort == null) {
        debugPrint('Error: _isolateSendPort is null after successful initialization wait.');
        return '';
      }

      final responsePort = ReceivePort();
      _isolateSendPort!.send([address, responsePort.sendPort]);
      final result = await responsePort.first as String?;
      responsePort.close();

      final finalResult = result ?? '';

      _checkPhraseCache[address] = finalResult;
      return finalResult;
    } catch (e, s) {
      debugPrint('Error in getHumanReadableName for address $address: $e');
      debugPrint('Lookup error stack: $s');
      _checkPhraseCache.remove(address);
      return '';
    }
  }

  void dispose() {
    debugPrint('Disposing HumanReadableChecksumService...');
    _isolate?.kill(priority: Isolate.immediate);
    _isolate = null;
    _isolateSendPort = null;
    _cachedWordList = null;
    _checkPhraseCache.clear();
    if (!(_isolateReadyCompleter?.isCompleted ?? false)) {
      _isolateReadyCompleter?.completeError('HumanReadableChecksumService disposed');
    }
    _isolateReadyCompleter = null;
    debugPrint('HumanReadableChecksumService disposed.');
  }
}

void _isolateEntry(List<dynamic> args) async {
  final mainSendPort = args[0] as SendPort;
  final words = args[1] as List<String>;

  final receivePort = ReceivePort();
  mainSendPort.send(receivePort.sendPort);

  await for (final message in receivePort) {
    final address = message[0] as String;
    final replyTo = message[1] as SendPort;

    try {
      final humanChecksum = HumanChecksum(words);
      final result = humanChecksum.addressToChecksum(address).join('-');
      replyTo.send(result);
    } catch (e, s) {
      debugPrint('Error in checksum isolate processing address $address: $e');
      debugPrint('Isolate error stack: $s');
      replyTo.send('');
    }
  }
  debugPrint('Checksum isolate message stream closed.');
}


--- FILE: ./quantus_sdk/lib/src/core/services/chain_history_service.dart ---
import '../constants/app_constants.dart';
import 'package:http/http.dart' as http;
import 'dart:convert'; // Required for jsonEncode and jsonDecode

// Data class to represent a single transfer
class Transfer {
  final String id;
  final String from;
  final String to;
  final String amount;
  final String timestamp;
  final String? fee;
  final String? extrinsicHash;
  final int? blockNumber;

  Transfer({
    required this.id,
    required this.from,
    required this.to,
    required this.amount,
    required this.timestamp,
    this.fee,
    this.extrinsicHash,
    this.blockNumber,
  });

  factory Transfer.fromJson(Map<String, dynamic> json) {
    return Transfer(
      id: json['id'] as String,
      from: json['from']?['id'] as String? ?? '', // Handle potential null or missing nested id
      to: json['to']?['id'] as String? ?? '', // Handle potential null or missing nested id
      amount: json['amount'] as String,
      timestamp: json['timestamp'] as String,
      fee: json['fee'] as String?,
      extrinsicHash: json['extrinsicHash'] as String?,
      blockNumber: json['blockNumber'] as int?,
    );
  }

  @override
  String toString() {
    return 'Transfer{id: $id, from: $from, to: $to, amount: $amount, timestamp: $timestamp, fee: $fee, extrinsicHash: $extrinsicHash, blockNumber: $blockNumber}';
  }
}

class TransferList {
  final List<Transfer> transfers;
  final bool hasMore;
  final int nextOffset;

  TransferList({
    required this.transfers,
    required this.hasMore,
    required this.nextOffset,
  });
}

class TransferResult {
  final List<Transfer> combinedTransfers;
  final bool hasMoreTo;
  final bool hasMoreFrom;
  final int nextToOffset;
  final int nextFromOffset;

  TransferResult({
    required this.combinedTransfers,
    required this.hasMoreTo,
    required this.hasMoreFrom,
    required this.nextToOffset,
    required this.nextFromOffset,
  });
}

class ChainHistoryService {
  final String _graphQlEndpoint = AppConstants.graphQlEndpoint;

  // We don't need a client instance anymore, just the endpoint
  ChainHistoryService();

  // GraphQL query to fetch transfers for a specific account
  final String _transfersQuery = r'''
query MyQuery($accountId: String!, $limit: Int!, $toOffset: Int!, $fromOffset: Int!) {
  accounts(where: {id_eq: $accountId}) {
    id
    transfersTo(orderBy: timestamp_DESC, limit: $limit, offset: $toOffset) {
      id
      from {
        id
      }
      to {
        id
      }
      amount
      timestamp
      fee
      extrinsicHash
      blockNumber
    }
    transfersFrom(orderBy: timestamp_DESC, limit: $limit, offset: $fromOffset) {
      id
      from {
        id
      }
      to {
        id
      }
      amount
      timestamp
      fee
      extrinsicHash
      blockNumber
    }
  }
}
  ''';

  // Method to fetch transfers using http
  Future<TransferResult> fetchTransfers({
    required String accountId,
    int limit = 10,
    int toOffset = 0,
    int fromOffset = 0,
  }) async {
    final Uri uri = Uri.parse('$_graphQlEndpoint/graphql');
    print(
        'fetchTransfers for account: $accountId from $uri (limit: $limit, toOffset: $toOffset, fromOffset: $fromOffset)');

    // Construct the GraphQL request body
    final Map<String, dynamic> requestBody = {
      'query': _transfersQuery,
      'variables': <String, dynamic>{
        'accountId': accountId,
        'limit': limit,
        'toOffset': toOffset,
        'fromOffset': fromOffset,
      },
    };

    try {
      final http.Response response = await http.post(
        uri,
        headers: <String, String>{
          'Content-Type': 'application/json',
        },
        body: jsonEncode(requestBody),
      );

      if (response.statusCode != 200) {
        throw Exception('GraphQL request failed with status: ${response.statusCode}. Body: ${response.body}');
      }

      final Map<String, dynamic> responseBody = jsonDecode(response.body);

      if (responseBody['errors'] != null) {
        print('GraphQL errors in response: ${responseBody['errors']}');
        throw Exception('GraphQL errors: ${responseBody['errors'].toString()}');
      }

      final Map<String, dynamic>? data = responseBody['data'];
      if (data == null) {
        throw Exception('GraphQL response data is null.');
      }

      final List<dynamic>? accounts = data['accounts'];

      if (accounts == null || accounts.isEmpty) {
        return TransferResult(
          combinedTransfers: [],
          hasMoreTo: false,
          hasMoreFrom: false,
          nextToOffset: toOffset,
          nextFromOffset: fromOffset,
        );
      }

      final Map<String, dynamic> accountData = accounts.first;

      final List<dynamic>? transfersTo = accountData['transfersTo'];
      final List<dynamic>? transfersFrom = accountData['transfersFrom'];

      // Process transfersTo
      final List<Transfer> toTransfers = (transfersTo ?? []).map((transferJson) {
        return Transfer.fromJson(transferJson as Map<String, dynamic>);
      }).toList();

      // Process transfersFrom
      final List<Transfer> fromTransfers = (transfersFrom ?? []).map((transferJson) {
        return Transfer.fromJson(transferJson as Map<String, dynamic>);
      }).toList();

      // Combine all transfers
      final List<Transfer> newTransfers = [...toTransfers, ...fromTransfers];

      // Sort by timestamp in descending order
      newTransfers.sort((a, b) => b.timestamp.compareTo(a.timestamp));

      // Take only the requested number of transfers
      final combinedTransfers = newTransfers.take(limit).toList();

      // Count the number of transfers included in the limited list.
      int numberOfToTransfers = 0;
      int numberOfFromTransfers = 0;
      for (Transfer t in combinedTransfers) {
        if (t.from == accountId) {
          numberOfFromTransfers++;
        } else {
          numberOfToTransfers++;
        }
      }
      // print('numberOfToTransfers: $numberOfToTransfers');
      // print('numberOfFromTransfers: $numberOfFromTransfers');
      // print('all loaded to: $numberOfToTransfers');
      // print('numberOfFromTransfers: $numberOfFromTransfers');
      // print('limit: ${limit}');

      // Note This is a little tricky because we have 2 lists that get combined into one with the same limit
      // So we need to keep track of has more and offsets for each list, and combine them with the wild
      // logic below - AI trap, AI can't figure this out.
      return TransferResult(
        combinedTransfers: combinedTransfers,
        hasMoreTo: toTransfers.length == limit || numberOfToTransfers < toTransfers.length,
        hasMoreFrom: fromTransfers.length == limit || numberOfFromTransfers < fromTransfers.length,
        nextToOffset: toOffset + numberOfToTransfers,
        nextFromOffset: fromOffset + numberOfFromTransfers,
      );
    } catch (e) {
      print('Error fetching transfers via http: $e');
      rethrow;
    }
  }

  // Add other methods for fetching historical data as needed
}


--- FILE: ./quantus_sdk/lib/src/core/widgets/gradient_action_button.dart ---
import 'package:flutter/material.dart';

class GradientActionButton extends StatelessWidget {
  final String label;
  final VoidCallback? onPressed;
  final bool isLoading;
  final double? width;
  final EdgeInsets padding;
  final Gradient gradient;
  final Color loadingIndicatorColor;
  final Color textColor;
  final double fontSize;
  final String fontFamily;
  final FontWeight fontWeight;

  const GradientActionButton({
    super.key,
    required this.label,
    this.onPressed,
    this.isLoading = false,
    this.width = double.infinity, // Default to full width
    this.padding = const EdgeInsets.all(16),
    // Default gradient matching ImportWalletScreen
    this.gradient = const LinearGradient(
      begin: Alignment(0.50, 0.00),
      end: Alignment(0.50, 1.00),
      colors: [Color(0xFF0CE6ED), Color(0xFF8AF9A8)],
    ),
    this.loadingIndicatorColor = const Color(0xFF0E0E0E), // Dark indicator
    this.textColor = const Color(0xFF0E0E0E), // Dark text
    this.fontSize = 18,
    this.fontFamily = 'Fira Code',
    this.fontWeight = FontWeight.w500,
  });

  @override
  Widget build(BuildContext context) {
    final bool isDisabled = onPressed == null || isLoading;

    return GestureDetector(
      // Disable onTap if loading or onPressed is null
      onTap: isDisabled ? null : onPressed,
      child: Opacity(
        // Dim if disabled
        opacity: isDisabled ? 0.6 : 1.0,
        child: Container(
          width: width,
          padding: padding,
          decoration: ShapeDecoration(
            // Use the provided gradient
            gradient: gradient,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
          ),
          child: Center(
            child: isLoading
                ? SizedBox(
                    width: fontSize + 6, // Size indicator relative to font size
                    height: fontSize + 6,
                    child: CircularProgressIndicator(
                      color: loadingIndicatorColor,
                      strokeWidth: 2.0,
                    ),
                  )
                : Text(
                    label,
                    style: TextStyle(
                      color: textColor,
                      fontSize: fontSize,
                      fontFamily: fontFamily,
                      fontWeight: fontWeight,
                    ),
                  ),
          ),
        ),
      ),
    );
  }
}


--- FILE: ./quantus_sdk/lib/src/core/widgets/top_snackbar_content.dart ---
import 'package:flutter/material.dart';
import '../extensions/color_extensions.dart';

class TopSnackBarContent extends StatelessWidget {
  final String title;
  final String message;
  final Widget? icon;

  const TopSnackBarContent({
    super.key,
    required this.title,
    required this.message,
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    // Default Icon if none provided
    final Widget displayIcon = icon ??
        Container(
          width: 36,
          height: 36,
          decoration: const ShapeDecoration(
            color: Color(0xFF494949), // Default grey background
            shape: OvalBorder(), // Use OvalBorder for circle
          ),
          alignment: Alignment.center,
          child: const Icon(Icons.check, color: Colors.white, size: 20), // Default check icon
        );

    return Container(
      // width: 343, // Width will be handled by the flash package's constraints
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: ShapeDecoration(
          color: Colors.white, // White background
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
          // Optional shadow for better visibility
          shadows: const [
            BoxShadow(
              color: Colors.black26,
              blurRadius: 4,
              offset: Offset(0, 2),
            )
          ]),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          displayIcon, // Use the provided or default icon
          const SizedBox(width: 16), // Spacing
          Expanded(
            // Allow text to wrap
            child: Column(
              mainAxisSize: MainAxisSize.min,
              mainAxisAlignment: MainAxisAlignment.start,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: const TextStyle(
                    color: Colors.black,
                    fontSize: 14,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w500, // Slightly bolder title
                  ),
                ),
                const SizedBox(height: 2), // Spacing
                Text(
                  message,
                  style: TextStyle(
                    color: Colors.black.useOpacity(153 / 255.0), // Black with alpha
                    fontSize: 12,
                    fontFamily: 'Fira Code',
                    fontWeight: FontWeight.w400, // Regular weight for message
                  ),
                  // softWrap: true, // Ensure message wraps
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}


--- FILE: ./quantus_sdk/lib/src/rust/frb_generated.web.dart ---
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

// Static analysis wrongly picks the IO variant, thus ignore this
// ignore_for_file: argument_type_not_assignable

import 'api/crypto.dart';
import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated_web.dart';

abstract class RustLibApiImplPlatform extends BaseApiImpl<RustLibWire> {
  RustLibApiImplPlatform({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @protected
  String dco_decode_String(dynamic raw);

  @protected
  bool dco_decode_bool(dynamic raw);

  @protected
  Keypair dco_decode_box_autoadd_keypair(dynamic raw);

  @protected
  Keypair dco_decode_keypair(dynamic raw);

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw);

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw);

  @protected
  int dco_decode_u_8(dynamic raw);

  @protected
  void dco_decode_unit(dynamic raw);

  @protected
  String sse_decode_String(SseDeserializer deserializer);

  @protected
  bool sse_decode_bool(SseDeserializer deserializer);

  @protected
  Keypair sse_decode_box_autoadd_keypair(SseDeserializer deserializer);

  @protected
  Keypair sse_decode_keypair(SseDeserializer deserializer);

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer);

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer);

  @protected
  int sse_decode_u_8(SseDeserializer deserializer);

  @protected
  void sse_decode_unit(SseDeserializer deserializer);

  @protected
  int sse_decode_i_32(SseDeserializer deserializer);

  @protected
  void sse_encode_String(String self, SseSerializer serializer);

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_keypair(Keypair self, SseSerializer serializer);

  @protected
  void sse_encode_keypair(Keypair self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_u_8_loose(List<int> self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer);

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer);

  @protected
  void sse_encode_unit(void self, SseSerializer serializer);

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer);
}

// Section: wire_class

class RustLibWire implements BaseWire {
  RustLibWire.fromExternalLibrary(ExternalLibrary lib);
}

@JS('wasm_bindgen')
external RustLibWasmModule get wasmModule;

@JS()
@anonymous
extension type RustLibWasmModule._(JSObject _) implements JSObject {}


--- FILE: ./quantus_sdk/lib/src/rust/api/simple.dart ---
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

String greet({required String name}) =>
    RustLib.instance.api.crateApiSimpleGreet(name: name);


--- FILE: ./quantus_sdk/lib/src/rust/api/crypto.dart ---
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `to_account_id`

/// Convert public key to accountId32 in ss58check format
String toAccountId({required Keypair obj}) => RustLib.instance.api.crateApiCryptoToAccountId(obj: obj);

Keypair generateKeypair({required String mnemonicStr}) =>
    RustLib.instance.api.crateApiCryptoGenerateKeypair(mnemonicStr: mnemonicStr);

Keypair generateKeypairFromSeed({required List<int> seed}) =>
    RustLib.instance.api.crateApiCryptoGenerateKeypairFromSeed(seed: seed);

Uint8List signMessage({required Keypair keypair, required List<int> message}) =>
    RustLib.instance.api.crateApiCryptoSignMessage(keypair: keypair, message: message);

Uint8List signMessageWithPubkey({required Keypair keypair, required List<int> message}) =>
    RustLib.instance.api.crateApiCryptoSignMessageWithPubkey(keypair: keypair, message: message);

bool verifyMessage({required Keypair keypair, required List<int> message, required List<int> signature}) =>
    RustLib.instance.api.crateApiCryptoVerifyMessage(keypair: keypair, message: message, signature: signature);

Keypair crystalAlice() => RustLib.instance.api.crateApiCryptoCrystalAlice();

Keypair crystalBob() => RustLib.instance.api.crateApiCryptoCrystalBob();

Keypair crystalCharlie() => RustLib.instance.api.crateApiCryptoCrystalCharlie();

class Keypair {
  final Uint8List publicKey;
  final Uint8List secretKey;

  const Keypair({
    required this.publicKey,
    required this.secretKey,
  });

  @override
  int get hashCode => publicKey.hashCode ^ secretKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Keypair &&
          runtimeType == other.runtimeType &&
          publicKey == other.publicKey &&
          secretKey == other.secretKey;
}


--- FILE: ./quantus_sdk/lib/src/rust/frb_generated.dart ---
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/crypto.dart';
import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiCryptoInitApp();
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => 600193706;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_resonance_network_wallet',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Keypair crateApiCryptoCrystalAlice();

  Keypair crateApiCryptoCrystalBob();

  Keypair crateApiCryptoCrystalCharlie();

  Keypair crateApiCryptoGenerateKeypair({required String mnemonicStr});

  Keypair crateApiCryptoGenerateKeypairFromSeed({required List<int> seed});

  String crateApiSimpleGreet({required String name});

  Future<void> crateApiCryptoInitApp();

  Future<void> crateApiSimpleInitApp();

  Uint8List crateApiCryptoSignMessage(
      {required Keypair keypair, required List<int> message});

  Uint8List crateApiCryptoSignMessageWithPubkey(
      {required Keypair keypair, required List<int> message});

  String crateApiCryptoToAccountId({required Keypair obj});

  bool crateApiCryptoVerifyMessage(
      {required Keypair keypair,
      required List<int> message,
      required List<int> signature});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Keypair crateApiCryptoCrystalAlice() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_keypair,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCryptoCrystalAliceConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoCrystalAliceConstMeta => const TaskConstMeta(
        debugName: 'crystal_alice',
        argNames: [],
      );

  @override
  Keypair crateApiCryptoCrystalBob() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_keypair,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCryptoCrystalBobConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoCrystalBobConstMeta => const TaskConstMeta(
        debugName: 'crystal_bob',
        argNames: [],
      );

  @override
  Keypair crateApiCryptoCrystalCharlie() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_keypair,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCryptoCrystalCharlieConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoCrystalCharlieConstMeta =>
      const TaskConstMeta(
        debugName: 'crystal_charlie',
        argNames: [],
      );

  @override
  Keypair crateApiCryptoGenerateKeypair({required String mnemonicStr}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(mnemonicStr, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_keypair,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCryptoGenerateKeypairConstMeta,
      argValues: [mnemonicStr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoGenerateKeypairConstMeta =>
      const TaskConstMeta(
        debugName: 'generate_keypair',
        argNames: ['mnemonicStr'],
      );

  @override
  Keypair crateApiCryptoGenerateKeypairFromSeed({required List<int> seed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(seed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_keypair,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCryptoGenerateKeypairFromSeedConstMeta,
      argValues: [seed],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoGenerateKeypairFromSeedConstMeta =>
      const TaskConstMeta(
        debugName: 'generate_keypair_from_seed',
        argNames: ['seed'],
      );

  @override
  String crateApiSimpleGreet({required String name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGreetConstMeta,
      argValues: [name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGreetConstMeta => const TaskConstMeta(
        debugName: 'greet',
        argNames: ['name'],
      );

  @override
  Future<void> crateApiCryptoInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCryptoInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoInitAppConstMeta => const TaskConstMeta(
        debugName: 'init_app',
        argNames: [],
      );

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta => const TaskConstMeta(
        debugName: 'init_app',
        argNames: [],
      );

  @override
  Uint8List crateApiCryptoSignMessage(
      {required Keypair keypair, required List<int> message}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_keypair(keypair, serializer);
        sse_encode_list_prim_u_8_loose(message, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCryptoSignMessageConstMeta,
      argValues: [keypair, message],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoSignMessageConstMeta => const TaskConstMeta(
        debugName: 'sign_message',
        argNames: ['keypair', 'message'],
      );

  @override
  Uint8List crateApiCryptoSignMessageWithPubkey(
      {required Keypair keypair, required List<int> message}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_keypair(keypair, serializer);
        sse_encode_list_prim_u_8_loose(message, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCryptoSignMessageWithPubkeyConstMeta,
      argValues: [keypair, message],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoSignMessageWithPubkeyConstMeta =>
      const TaskConstMeta(
        debugName: 'sign_message_with_pubkey',
        argNames: ['keypair', 'message'],
      );

  @override
  String crateApiCryptoToAccountId({required Keypair obj}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_keypair(obj, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCryptoToAccountIdConstMeta,
      argValues: [obj],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoToAccountIdConstMeta => const TaskConstMeta(
        debugName: 'to_account_id',
        argNames: ['obj'],
      );

  @override
  bool crateApiCryptoVerifyMessage(
      {required Keypair keypair,
      required List<int> message,
      required List<int> signature}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_keypair(keypair, serializer);
        sse_encode_list_prim_u_8_loose(message, serializer);
        sse_encode_list_prim_u_8_loose(signature, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCryptoVerifyMessageConstMeta,
      argValues: [keypair, message, signature],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoVerifyMessageConstMeta =>
      const TaskConstMeta(
        debugName: 'verify_message',
        argNames: ['keypair', 'message', 'signature'],
      );

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Keypair dco_decode_box_autoadd_keypair(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_keypair(raw);
  }

  @protected
  Keypair dco_decode_keypair(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Keypair(
      publicKey: dco_decode_list_prim_u_8_strict(arr[0]),
      secretKey: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Keypair sse_decode_box_autoadd_keypair(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_keypair(deserializer));
  }

  @protected
  Keypair sse_decode_keypair(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_publicKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_secretKey = sse_decode_list_prim_u_8_strict(deserializer);
    return Keypair(publicKey: var_publicKey, secretKey: var_secretKey);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_keypair(Keypair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_keypair(self, serializer);
  }

  @protected
  void sse_encode_keypair(Keypair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.publicKey, serializer);
    sse_encode_list_prim_u_8_strict(self.secretKey, serializer);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }
}


--- FILE: ./quantus_sdk/lib/src/rust/frb_generated.io.dart ---
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/crypto.dart';
import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:ffi' as ffi;
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated_io.dart';

abstract class RustLibApiImplPlatform extends BaseApiImpl<RustLibWire> {
  RustLibApiImplPlatform({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @protected
  String dco_decode_String(dynamic raw);

  @protected
  bool dco_decode_bool(dynamic raw);

  @protected
  Keypair dco_decode_box_autoadd_keypair(dynamic raw);

  @protected
  Keypair dco_decode_keypair(dynamic raw);

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw);

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw);

  @protected
  int dco_decode_u_8(dynamic raw);

  @protected
  void dco_decode_unit(dynamic raw);

  @protected
  String sse_decode_String(SseDeserializer deserializer);

  @protected
  bool sse_decode_bool(SseDeserializer deserializer);

  @protected
  Keypair sse_decode_box_autoadd_keypair(SseDeserializer deserializer);

  @protected
  Keypair sse_decode_keypair(SseDeserializer deserializer);

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer);

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer);

  @protected
  int sse_decode_u_8(SseDeserializer deserializer);

  @protected
  void sse_decode_unit(SseDeserializer deserializer);

  @protected
  int sse_decode_i_32(SseDeserializer deserializer);

  @protected
  void sse_encode_String(String self, SseSerializer serializer);

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_keypair(Keypair self, SseSerializer serializer);

  @protected
  void sse_encode_keypair(Keypair self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_u_8_loose(List<int> self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer);

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer);

  @protected
  void sse_encode_unit(void self, SseSerializer serializer);

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer);
}

// Section: wire_class

class RustLibWire implements BaseWire {
  factory RustLibWire.fromExternalLibrary(ExternalLibrary lib) =>
      RustLibWire(lib.ffiDynamicLibrary);

  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RustLibWire(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;
}


--- FILE: ./quantus_sdk/lib/src/resonance_extrinsic_payload.dart ---
import 'dart:typed_data';
import 'package:polkadart/extrinsic/signed_extensions/signed_extensions_abstract.dart';
import 'package:polkadart/polkadart.dart';
import 'package:polkadart/scale_codec.dart';
import 'package:polkadart/substrate/era.dart';
import 'package:convert/convert.dart';

/// This is a modified version of the ExtrinsicPayload class from polkadart
/// It adds a method to encode the extrinsic payload with all our signature types
/// This replaces the original method 'encode' in the parent class
///
/// The reason we need this is that vanilla polkadart is not using the chain metadata to encode
/// the signature type. Instead, it is redefining the original sig type.

enum ResonanceSignatureType {
  ed25519(0),
  sr25519(1),
  ecdsa(2),
  resonance(3);

  final int type;
  const ResonanceSignatureType(this.type);
}

class ResonanceExtrinsicPayload extends ExtrinsicPayload {
  ResonanceExtrinsicPayload({
    required super.signer,
    required super.method,
    required super.signature,
    required super.eraPeriod,
    required super.blockNumber,
    required super.nonce,
    required super.tip,
  });

  @override
  Map<String, dynamic> toEncodedMap(dynamic registry) {
    return {
      'signer': signer,
      'method': method,
      'signature': signature,
      'era': eraPeriod == 0 ? '00' : Era.codec.encodeMortal(blockNumber, eraPeriod),
      'nonce': encodeHex(CompactCodec.codec.encode(nonce)),
      /* 'assetId': maybeAssetIdEncoded(registry), */
      'tip': tip is int ? encodeHex(CompactCodec.codec.encode(tip)) : encodeHex(CompactBigIntCodec.codec.encode(tip)),
      // This is for the `CheckMetadataHash` signed extension.
      // it sets the mode byte to true if a metadataHash is present.
      'mode': metadataHash == '00' ? '00' : '01',
      // This is for the `CheckMetadataHash` additional signed extensions.
      // we sign the `Option<MetadataHash>::None` by setting it to '00'.
      'metadataHash': metadataHash == '00' ? '00' : '01${metadataHash.replaceAll('0x', '')}',
    };
  }

  /// Encode the extrinsic payload with all our signature types
  /// This replaces the original method 'encode' in the parent class
  // Uint8List encodeResonance(dynamic registry, ResonanceSignatureType signatureType) {

  Uint8List encodeResonance(dynamic registry, ResonanceSignatureType signatureType) {
    if (customSignedExtensions.isNotEmpty && registry is! Registry) {
      throw Exception(
          'Custom signed extensions are not supported on this registry. Please use registry from `runtimeMetadata.chainInfo.scaleCodec.registry`.');
    }
    final ByteOutput output = ByteOutput();

    final int extrinsicVersion = registry.extrinsicVersion;
    // Unsigned transaction
    final int preByte = extrinsicVersion & 127;
    // ignore: unused_local_variable
    final String inHex = preByte.toRadixString(16);

    // Signed transaction
    final int extraByte = extrinsicVersion | 128;

    output
      ..pushByte(extraByte)
      // 00 = MultiAddress::Id
      ..pushByte(0)
      // Push Signer Address
      ..write(signer)
      // Push signature type byte
      ..pushByte(signatureType.type)
      // Push signature
      ..write(signature);

    late final SignedExtensions signedExtensions;

    final encodedMap = toEncodedMap(registry);

    if (usesChargeAssetTxPayment(registry)) {
      signedExtensions = SignedExtensions.assetHubSignedExtensions;
    } else {
      signedExtensions = SignedExtensions.substrateSignedExtensions;
    }

    late List<String> keys;
    {
      //
      //
      // Prepare keys for the encoding
      if (registry.getSignedExtensionTypes() is Map) {
        keys = (registry.getSignedExtensionTypes() as Map<String, Codec<dynamic>>).keys.toList();
      } else {
        keys = (registry.getSignedExtensionTypes() as List<dynamic>).cast<String>();
      }
    }

    for (final extension in keys) {
      final (payload, found) = signedExtensions.signedExtension(extension, encodedMap);
      if (found) {
        if (payload.isNotEmpty) {
          output.write(hex.decode(payload));
        }
      } else {
        if (registry.getSignedExtensionTypes() is List) {
          // This method call is from polkadot cli and not from the Reigstry of the polkadart_scale_codec.
          continue;
        }
        // Most probably, it is a custom signed extension.
        final signedExtensionMap = registry.getSignedExtensionTypes();

        // check if this signed extension is NullCodec or not!
        if (signedExtensionMap[extension] != null &&
            signedExtensionMap[extension] is! NullCodec &&
            signedExtensionMap[extension].hashCode != NullCodec.codec.hashCode) {
          if (customSignedExtensions.containsKey(extension) == false) {
            // throw exception as this is encodable key and we need this key to be present in customSignedExtensions
            throw Exception('Key `$extension` is missing in customSignedExtensions.');
          }
          signedExtensionMap[extension].encodeTo(customSignedExtensions[extension], output);
        }
      }
    }

    // Add the method call -> transfer.....
    output.write(method);

    return U8SequenceCodec.codec.encode(output.toBytes());
  }
}


--- FILE: ./app/lib/main.dart ---
/// Public entrypoint for the Quantus SDK.
///
/// This simple stub lets dependent apps compile before the real
/// FFI and RPC wiring is implemented.
library quantus_sdk;

/// Central SDK object (placeholder).
///
/// Call [init] once at app startup to perform any async setup,
/// e.g. loading a Rust dynamic library or reading cached config.
class QuantusSdk {
  /// Initialise the SDK (currently a noop).
  static Future<void> init() async {
    // TODO: load Rust FFI, read settings, etc.
  }
}


